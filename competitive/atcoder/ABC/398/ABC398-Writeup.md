# ABC398 - Writeup

## C - Uniqueness

### 問題概要
1 から $N$ まで番号がついた $N$ 人がいて、それぞれが整数 $A_i$ を持っている。  
「自分以外に同じ値を持つ人がいない」人の中で、**最大の値を持つ人の番号**を出力する。  
そのような人が存在しない場合は `-1` を出力する。

---

### 制約
- $1 \leq N \leq 3 \times 10^5$  
- $1 \leq A_i \leq 10^9$  
- 入力はすべて整数である。

計算量制約的に **$$O(N \log N)$$** 以下での解法が求められる。

---

### 方針
1. 各数値 $A_i$ が出現する **回数** を求める。  
2. 出現回数が 1 回だけの値（＝一意な値）を抽出する。  
3. その中から最大値を求める。  
4. その値を持つ人のインデックス（1-based）を出力する。  
5. 一意な値が存在しない場合は `-1` を出力する。  

---

### Pythonによる実装例

```python
from collections import defaultdict

N = int(input())
A = list(map(int, input().split()))

d = defaultdict(list)
for i, a in enumerate(A):
    d[a].append(i)

for key in sorted(d, reverse=True):
    if len(d[key]) == 1:
        print(d[key][0] + 1)
        exit()

print(-1)
```

#### ポイント

* `defaultdict(list)` で値ごとにインデックスを保存。
* 辞書を降順ソートし、最初に「出現1回」の要素を見つけた時点で出力・終了。
* 計算量は **$O(N \log N)$**（ソート分）で十分高速。

---

### 検証例

#### 入力例 1

```
5
1 2 2 3 1
```

#### 出力例 1

```
4
```

一意な値は $3$ のみ。
$3$ を持つ人は $4$ 番 → 出力 $4$。

---

#### 入力例 2

```
4
1 1 1 1
```

#### 出力例 2

```
-1
```

すべての値が重複しており、一意な人はいない。

---

### まとめ

* **核心的な考え方:** 出現回数が 1 の要素を見つけ、その中で最大値を取る。
* **Python版:** 辞書とソートを用いてシンプルに実装できる。
* **計算量:** 

    python版: $O(N \log N)$。

    Rust版: $O(N)$

---
