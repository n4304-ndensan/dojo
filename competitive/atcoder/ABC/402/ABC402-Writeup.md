## C - Dislike Foods

---

## 問題概要

* **N** 種類の食材 (1..N)
* **M** 個の料理 (1..M)

  * 料理 i には Ki 個の食材が使われる
* すぬけ君は最初すべての食材が嫌いで食べられない
* i 日目に食材 Bi を克服し、それ以降は苦手ではなくなる
* 各日ごとに「その時点で食べられる料理数」を出力

---

## 制約

* N, M ≤ 3×10^5
* Σ Ki ≤ 3×10^5
* Bi は 1..N の順列（各食材は一度だけ克服）

---

## 愚直解法と問題点

### 愚直実装の流れ

* 各日で食材 Bi を削除
* すべての料理について「その食材を含むか」を探索
* 食材が空になった料理を食べられるとカウント

### 計算量

* 料理ごとに `.contains` を回すと **O(N × ΣKi)**
* N, M, ΣKi が最大 3×10^5 なので **O(10^10)** 以上 → **TLE**

---

## [[転置]]の発想（効率化のカギ）

* 「料理 → 食材」ではなく「食材 → 料理」を管理する
* 各食材がどの料理に含まれるかを逆引きできるようにする
* 食材 Bi を克服したら、その食材に関連する料理だけ更新すればよい

---

## 解法の流れ（転置アプローチ）

1. **前処理**

   * `foodToMenus[food]` = その食材を含む料理一覧
   * `remaining[menu]` = 料理 menu に残っている嫌い食材数（初期値 = Ki）

2. **各日 (食材 Bi を克服)**

   * `foodToMenus[Bi]` に含まれる料理をすべて確認
   * 料理の `remaining` を 1 減らす
   * `remaining == 0` になったら「食べられる料理数」を +1

3. **累計を出力**

   * `completedMenus` を更新しつつ出力

### 計算量

* 各食材・各料理は関連する分だけしか減算されない
* 更新回数は高々 ΣKi（≤ 3×10^5）
* 全体で **O(N + ΣKi)** で解ける

---

## 学びポイント

* **順方向より逆方向の依存関係を持つ方が効率的**
* `contains` 検索は O(K) になるが、転置すれば O(ΣKi)
* 大規模制約では「各要素の寄与を1回ずつ処理する」ことを意識する

---

## まとめ

* 愚直だと全探索で間に合わない
* 転置して「食材 → 料理」を管理することで高速化
* 計算量 O(N + ΣKi) で AC
