# writeup.md

## 問題概要

* ユーザー数 **N**、コンテンツページ数 **M**、クエリ数 **Q** が与えられる。
* 3種類のクエリが存在する：

  1. `1 u v` : ユーザー `u` にコンテンツページ `v` へのアクセス権を付与する
  2. `2 u` : ユーザー `u` に「全ページへのアクセス権」を付与する
  3. `3 u v` : ユーザー `u` がコンテンツページ `v` にアクセスできるかを判定する

出力は、タイプ 3 のクエリごとに `Yes` または `No` を出力する。

---

## 制約

* `1 ≤ N, M, Q ≤ 2×10^5`
* 実行時間制限: 2 sec
* メモリ制限: 1024 MB

---

## 考察

### 1. 単純配列は無理

`boolean[N+1][M+1]` で全権限を管理すると、
最大で **(200,001 × 200,001) ≈ 40,000,000,000 ≈ 40GB** 必要。
→ メモリ制限 1GB を超えるため不可能。

### 2. 必要なものだけ保存する

クエリ数は最大 `Q=2×10^5` なので、実際にアクセスする `(user, page)` ペアは **多くても 20万件**。
したがって、全体を配列に持つ必要はなく、\*\*疎構造（HashSetなど）\*\*で十分。

---

## 解法戦略

1. 各ユーザーが「全ページ権限を持つかどうか」を `boolean[] allAuthority` で管理する。
2. 各ユーザーごとの「個別ページ権限」は `Map<Integer, Set<Integer>>` で管理する。

   * `key = user`
   * `value = ページ番号の集合`
   * `Set` を使う理由：重複を許さない＆検索が O(1) 平均。

---

## 計算量・メモリ量

* **計算量**

  * クエリごとに O(1) （平均、HashSet/HashMap利用）。
  * 合計 O(Q) = 2×10^5 → 2 秒以内に余裕で収まる。

* **メモリ量**

  * `boolean[N]` → 約 200 KB
  * `Map<Integer, Set<Integer>>` → 最大 Q 要素 ≈ 数 MB
  * 1GB 制限内に収まる。

---

## まとめ

* 全ユーザー×ページを配列に持つのは **40GB 必要で不可能**。
* **全権限フラグ + 個別権限を HashSet で管理**することで、効率よく判定できる。
* 典型的な「大きな制約 → 疎なデータ構造を選ぶ」タイプの問題。
