# Black Intervals 問題 解法メモ

## 問題概要

- 1 から N までのマスがあり、最初はすべて白。
- クエリで「マス X の色を反転」する。
- 各クエリ後に「黒マスが連続する区間の数」を答える。

便宜上、マス列の両端に常に白の番兵（マス 0, マス N+1）を置いて考える。

---

## 単純解法とその問題点

- 反転のたびに全体を走査し、黒区間を数える方法が考えられる。
- しかしこれは O(N) かかり、Q 回繰り返すと O(NQ) となり大きな入力では間に合わない。

---

## 高速化の着想

次の量を定義する：

- **境界数 k** = 色が異なる隣接ペア (i, i+1) の個数 (0 ≤ i ≤ N)

このとき以下が成り立つ：

- 黒区間の数は `k / 2`
- 理由：境界が現れるごとに「黒区間の開始」「黒区間の終了」が交互に対応するため。
- 端のマス 0, N+1 は白で固定されているため、境界数 k は必ず偶数になる。

---

## クエリ処理

マス X を反転したときに変わるのは **境界 (X-1, X)** と **境界 (X, X+1)** のみ。  
それぞれについて、

- 反転前に同色なら → 異色になる（境界数 +1）
- 反転前に異色なら → 同色になる（境界数 -1）

したがって 1 クエリあたり境界数の変化は ±2 または 0。  
境界数を更新すれば黒区間数は即座に `k/2` と分かる。

---

## 計算量

- 各クエリごとに定数回の処理（境界の確認と更新）だけを行う。
- 全体で O(Q)。

---

## 関連アルゴリズム・テクニック

- **境界法（差分管理）**  
  区間を直接扱わず、隣接要素の変化点だけを管理するテクニック。
- **トグル更新（XOR）**  
  0/1 の切り替えを効率よく表現する発想。
- **スイープライン的思考**  
  区間の数を「境界の数」で間接的に求めるアプローチ。

---

## まとめ

- 区間を直接数えるのではなく、境界数を管理することで高速化が可能。
- クエリあたり O(1)、全体 O(Q) で解ける。
- 競技プログラミングでよく使う「境界法」「差分管理」の良い応用例である。
