# C: Palindromic in Both Bases

## 問題情報

- **Description:**
  整数 `n` 以下のすべての **10 進数で回文となる数**を列挙する。
  さらに、その数を基数 `a` に変換したときも回文となっている場合のみ採用し、
  それらの総和を出力せよ。

---

## 解法

### アルゴリズム概要

1. **10 進数回文を生成**

   - 「上半分」の数字を決めれば回文が一意に定まる性質を利用。
   - 桁数 `len` を決めて、`half_len = (len+1)/2` の範囲で全探索。
   - 例えば `len=3`、`half=66` → "66" + "6" = "666"。

2. **範囲制御 (`n` 以下)**

   - 生成した回文 `pal` が `n` を超えたら、その桁の探索を打ち切る。
   - 次の桁数に入る前に `start > n` で全体を終了する。

3. **基数 a での回文判定**

   - 生成した回文を `a` 進数に変換し、文字列が回文かどうかを判定。
   - 回文なら総和に加算。

---

### アルゴリズム挙動（例: n=666, a=8）

- 1 桁: 1〜9 すべて回文 → 採用条件をチェック。
- 2 桁: 11,22,…,99 を生成。
- 3 桁: 101,111,…,666 を生成。
- 667 以降は制約で停止。
- それぞれを 8 進数に変換して再度回文判定。
- 条件を満たしたものだけ総和に加算。

---

## 実装のポイント

- **回文生成の効率化**: 全探索せず、桁数と上半分の数字だけを使う。
- **安全な範囲チェック**: `s.len()` と `n.to_string().len()` を比較し、`u64` に収まらない数を生成しないようにする。
- **基数変換**: 整数を繰り返し割り算して文字列にし、逆順に並べる。

---

## 計算量

- 10 進回文生成は桁数ごとに `O(10^(len/2))`。
- 基数変換と回文チェックは `O(len)`。
- 制約 `n ≤ 10^12` 程度なら十分高速。

---

## 関連技術

- 回文判定（左右からの比較）
- 基数変換（整数 → 文字列）
- 文字列操作と範囲打ち切り

---
