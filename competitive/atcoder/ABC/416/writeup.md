# C Concat (X-th)

## 問題情報

- **Description:**
  N 個の文字列 $S_1, S_2, \dots, S_N$ が与えられる。
  全ての要素が $1 \leq A_i \leq N$ であるような長さ $K$ の数列 $(A_1, \dots, A_K)$ に対して、

  ```math
  f(A*1, \dots, A_K) = S*{A*1} + S*{A*2} + \cdots + S*{A_K}
  ```

  を定義する（ここで + は文字列連結）。

  $N^K$ 通りの数列すべてについて $f(A_1, \dots, A_K)$ を列挙し、辞書順に並べたとき、
  **小さい方から X 番目の文字列**を求めよ。

- **制約**

  - $1 \leq N \leq 10$
  - $1 \leq K \leq 5$
  - $1 \leq X \leq N^K$
  - $S_i$ は英小文字からなる長さ 10 以下の文字列

---

## 解法

### 愚直な方法

まず素直に考えると、すべての長さ $K$ の組み合わせ（$N^K$ 個）を生成してソートし、
$X$ 番目を出力すればよい。

- DFS などで文字列を全列挙
- リストに入れてソート
- $ans[X-1]$ を出力

ただし、制約的に $N \leq 10, K \leq 5$ なので、最大でも $10^5 = 100,000$ 通りしか生成されない。
→ **このまま愚直解法でも十分間に合う**。

---

### 実装方針

1. 入力文字列 $S$ を読み込み、ソートしておく（辞書順を担保するため）。
2. DFS あるいは全探索で $N^K$ 通りの文字列を生成する。
3. 辞書順にソートし、$X$ 番目を取り出す。

---

## 計算量

- 組み合わせ総数は $N^K$ （最大 $10^5$）。
- 生成：$O(N^K)$
- ソート：$O(N^K \log(N^K))$
- 制約が小さいため十分高速。

---

## 関連技術

- DFS / 再帰による列挙
- 全探索（brute force）
- ソートによる辞書順処理

---
