# C Flush

## 問題

袋が $n$ 個あり、それぞれの袋には異なる種類のティーバッグが入っている。
袋ごとの種類は同じだが、**中身の個数 $A_i$ は異なる**。

ゲームは次のように行われる：

1. ディーラーが全体から $X$ 個のティーバッグを選ぶ。
2. プレイヤーはその中から **ちょうど $q$ 個** を選び取る。
3. 選んだ $q$ 個がすべて同じ種類なら勝ち。

ただし、ディーラーはプレイヤーが負けるように最善を尽くす。

このとき、**勝利するために必要な最小の $X$ を求めよ**。
勝てない場合は $-1$ を出力する。

---

## 解法

まず愚直に考えると、答えは次の式で表される：

$$
\text{ans} = 1 + \sum_{i=1}^{n} \min(b-1, A_i)
$$

ただし $b = q$。

なぜなら、各袋に対して「ディーラーが渡してくれる最大数」は $\min(b-1, A_i)$ だからである。
→ この方法だと計算量は $O(nq)$ となり、制約下では 2 秒を超えてしまう。

---

### 式の分解

$$
\sum_{i=1}^{n} \min(b-1, A_i)
= \underbrace{\sum_{\substack{1 \leq i \leq n \\ A_i < b}} A_i}_{\text{小さい方の総和}}
+ \underbrace{(n - \text{cnt}[b-1]) \cdot (b-1)}_{\text{大きい方の寄与}}
$$

ここで

- $\text{cnt}[b-1]$ は「$A_i \leq b-1$ の個数」
- 累積和 $\text{sum}[b-1]$ を持っておけば、前者は $\text{sum}[b-1]$ として高速に求められる。

最終的な答えは次の式になる：

$$
\text{ans} = 1 + \text{sum}[b-1] + (n - \text{cnt}[b-1]) \cdot (b-1)
$$

---

### 計算量

- 前処理：累積和と累積個数を計算する $O(\max A)$
- 各クエリ：定数時間 $O(1)$
- よって全体計算量は $O(n + \max A + q)$ で十分高速。

---

## 関連アルゴリズム等

- 累積和（prefix sum）
- counting 配列を用いた高速化
- min の分解による式変形

---
