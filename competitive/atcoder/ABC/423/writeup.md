# writeup.md

## 問題概要

* 部屋が `0,1,...,N` と並んでいる。
* ドアは `1,...,N` に対応し、ドア `i` は部屋 `i-1` と部屋 `i` の間にある。
* ドアの状態

  * `Li=0` → 開いている
  * `Li=1` → 閉まっている
* 高橋君は部屋 `R` にいる。
* 移動可能条件: 開いているドア（`Li=0`）があれば、そのドアを通って隣の部屋に移動できる。
* 操作可能条件: ドア `i` の両端どちらかの部屋にいるときに、そのドアの状態を反転できる。

**目的**

* すべてのドアを閉める（`Li=1` にする）。
* このとき必要な **開閉操作の最小回数** を求める。

---

## 制約

* `2 ≤ N ≤ 2×10^5`
* `0 ≤ R ≤ N`
* 入力サイズが大きいため、**O(N)** で解く必要がある。

---

## 考え方

1. **閉じているドアの数は数えなくてよい**。開いているドア(`Li=0`)をすべて閉じる必要がある。
   → なので基本的に `open = Li==0 の個数` は必ず操作に含まれる。

2. ただし「閉じる操作」を行うには、そのドアの近くまで移動しなければならない。
   → そのために「通り道にある閉じたドア (`Li=1`) を一度開けて通過し、再び閉める」必要がある。

   ⇒ 結果的に **余分な操作は「通り道の1ドアにつき +2回」** かかる。

3. したがって、

   * 左端から最初に開いているドアの位置 `left`
   * 右端から最後に開いているドアの位置 `right`
     を見つける。

4. スタート位置 `R` が `left` から `right` のどこにあるかで場合分けする：

   * `left <= R-1` の場合、`[left+1, R-1]` にある閉じたドアを通過する必要がある。
   * `right >= R` の場合、`[R, right-1]` にある閉じたドアを通過する必要がある。

   → これらの「閉じたドア」を通過するたびに `+2` 操作。

5. 最終的な答えは:

   ```
   ans = open + 2 * close
   ```

   となる。

---

## 実装の流れ

1. 入力を受け取る。
2. 左端の開いたドア (`left`) を見つける。
3. 右端の開いたドア (`right`) を見つける。
4. 開いたドアの総数 (`open`) を数える。
5. 通過のために必要な閉じたドアの数 (`close`) を数える。
6. 答えを出力する。

---

## 計算量

* 配列を数回走査するだけ。
* 時間計算量 **O(N)**、空間計算量 **O(N)**。

---

このアルゴリズムで制約 `N ≤ 2×10^5` でも余裕で解ける。

---

要約すると、「答え = 開いたドアの数 + 2 × 通過のために開閉が必要な閉じたドアの数」という式に帰着できる、ということです。

---
