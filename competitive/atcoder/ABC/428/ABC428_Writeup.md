#競技プログラミング #AtCoder #ABC428

# ABC428 Writeup

本書は **AtCoder Beginner Contest 428 (ABC428)** の各問題（A〜C）の解法を整理した技術的Writeupである。
各節では、**問題概要 → 制約分析 → 解法設計 → 計算量評価 → 実装上の注意点**の順に述べる。

---

## A - Grandma's Footsteps

### 問題概要

高橋君は毎秒 $S$ メートルで $A$ 秒間走り、続く $B$ 秒間静止するというサイクルを繰り返す。チャイムから $X$ 秒後の**総走行距離**を求める。

### 制約

* $1 \le S \le 15$
* $1 \le A,B \le 1000$
* $1 \le X \le 1000$

### 解法設計

1サイクルは $A+B$ 秒。完全サイクル数 $c = \lfloor X/(A+B) \rfloor$、余り $r = X \bmod (A+B)$ とする。

走行時間は $T = cA + \min(A, r)$、距離は $D = ST$ で求まる。

### 計算量評価

* 時間: $O(1)$
* 空間: $O(1)$

### 実装上の注意点

整数演算のみで処理可能。オーバーフローは起こらない。

---

## B - Most Frequent Substrings

### 問題概要

長さ $N$ の文字列 $S$ から、長さ $K$ の部分文字列のうち**最頻出のものを辞書順に列挙**する。

### 制約

* $1 \le K \le N \le 100$
* $S$ は英小文字

### 解法設計

長さ $K$ の部分文字列 $S[i..i+K)$ をすべて列挙し、`HashMap<String, usize>` により頻度を数える。
最大頻度を取得し、該当文字列を辞書順にソートして出力する。

### 計算量評価

* 列挙: $O(NK)$
* ソート: $O(M \log M)$ （$M$は最頻集合の個数）

### 実装上の注意点

部分文字列生成コストに注意。Rust の `S[i..i+K].to_string()` は十分高速。

---

## C - Brackets Stack Query

### 問題概要

空文字列から始まる括弧列 $S$ に対し、以下2種類の操作を処理し、**各操作後に $S$ が良い括弧列であるか**を判定する。

1. `1 c`: 末尾に `c`（'(' または ')'）を追加
2. `2`: 末尾の文字を削除

良い括弧列とは、連続部分文字列 `()` を繰り返し除去して空文字列にできる括弧列のことである。

### 制約

* $1 \le Q \le 8\times10^5$
* 操作 2 のとき、$S$ は空でない
* 計算量制約が厳しいため、**各クエリを amortized $O(1)$** で処理する必要がある

### 解法設計

良い括弧列の判定条件は以下の通りである：

* 部分和（左括弧を +1、右括弧を −1 とする）が **一度も負にならない**
* 最終的な総和が **0**

任意時点の $S$ を前から全走査するのは不可能（$Q$ が大きい）ため、**部分和の末尾値のみ管理するスタック**を用いる。

#### スタック管理方法

* push

  * `'('` の場合：直前値 + 1
  * `')'` の場合：直前値 − 1（ただし 0 を割り込む場合は即座に不正とするため、極小値を入れて負検出）

* pop

  * 末尾値を取り除くだけ

#### 判定

* スタックが空 → 良い括弧列
* スタック末尾が 0 → 良い括弧列
* それ以外 → 悪い括弧列

#### Rust 実装のポイント

与えられたコードは `VecDeque<i32>` により部分和を保持し、`MIN_INF` により負検出を行っている。各操作は $O(1)$ である。

### 計算量評価

* 各クエリ: $O(1)$
* 全体: $O(Q)$
* メモリ: $O(Q)$（最悪で全 push の場合）

### 実装上の注意点

* 右括弧追加時の負判定を必ず即座に行う
* 削除クエリでは必ずスタックは空でないことが保証される
* 出力は逐次行うため高速IOを推奨

---

## 総評

| 問題 | 分類       | アルゴリズム         | 計算量     |
| -- | -------- | -------------- | ------- |
| A  | シミュレーション | 周期処理           | $O(1)$  |
| B  | 文字列処理    | ハッシュ + ソート     | $O(NK)$ |
| C  | データ構造    | 部分和スタックによる括弧判定 | $O(Q)$  |
