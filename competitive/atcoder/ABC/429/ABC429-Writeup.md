# ABC429 - Writeup.md

## A - Too Many Requests

### 問題概要

正整数 ( N, M ) が与えられる。( i ) 行目（1 ≤ i ≤ N）に対して、

* ( i \le M ) のときは `OK`
* それ以外のときは `Too Many Requests`
  を出力する問題。

### 制約

* 1 ≤ N, M ≤ 10

### 方針

単純なループと条件分岐で解決できる。1 から N まで順にループし、i が M 以下なら `OK`、それ以外なら `Too Many Requests` を出力する。

### ポイント

* 非常に単純な条件分岐問題。
* 競技プログラミング入門として典型的な if 文処理。

---

## B - N - 1

### 問題概要

長さ ( N ) の整数列 ( A = (A_1, A_2, \ldots, A_N) ) と整数 ( M ) が与えられる。A の要素から 1 つを取り除き、残りの ( N-1 ) 個の和をちょうど ( M ) にできるかどうかを判定する問題。

### 制約

* 2 ≤ N ≤ 100
* 0 ≤ M ≤ 10000
* 0 ≤ A_i ≤ 100

### 方針

* まず A の総和を求める。
* 各要素 a を取り除いたときの和が ( M ) になるか確認する。
* つまり、`sum - a == M` となる a が存在するかどうかを調べる。

### ポイント

* `Vec::with_capacity(n)` で効率よくメモリ確保。
* `sum - a == m` という単純な差分チェックで十分。
* `.iter()` を使って所有権を消費せずループしている点が良い。

### 改良案

`.any()` を用いればより簡潔に書ける：

```rust
if arr.iter().any(|&a| sum - a == m) {
    println!("Yes");
} else {
    println!("No");
}
```

---

# C – Odd One Subsequence

### 問題概要

長さ $N$ の整数列 $A = (A_1, A_2, \ldots, A_N)$ が与えられる。
$1 \le i < j < k \le N$ を満たす整数の組 $(i,j,k)$ のうち、
${A_i, A_j, A_k}$ に **ちょうど2種類の値** が含まれるもの、すなわち「3つの要素のうち2つは等しく、残り1つが異なる」ものの個数を求めよ。 ([CSDN][1])

---

### 制約

* $3 \le N \le 2 \times 10^5$ ([CSDN][1])
* $1 \le A_i \le N$ （すべて整数） ([CSDN][1])

---

### 方針

* 単純に3重ループで $(i,j,k)$ を全探索すると $\binom{N}{3}\approx O(N^3)$ となり、最大 $N\approx2\times10^5$ では明らかに現実的でない。

* 値ごとの出現回数に着目する。数値 $v$ が配列中に $cnt[v]$ 回出現しているとする。

* その「同じ値を2つ選び、かつ異なる値を1つ選ぶ」構造を考えると：

  * 同じ値 $v$ を2つ選ぶ組み合わせ数は
    $$\binom{cnt[v]}{2} = \frac{cnt[v] \cdot (cnt[v] - 1)}{2}$$

  * 残り1つは「値 $v$ 以外」の中から1つ選ぶので、
    $$(N - cnt[v])$$
    通り。

* よって、値 $v$ を「多数をなす値（等しい2つ）」に選んだ場合の組み合わせ数は
  $$\binom{cnt[v]}{2} \times (N - cnt[v])$$

* これをすべての値 $v$ について足し合わせれば答えとなる。 ([Qiita][2])

* 計算量としては出現回数の集計が $O(N)$、その後値ごとに1回ずつ計算すればよく、合計 $O(N)$ 程度となる。

---

### 計算量評価

* 時間計算量：入力長 $N$ の集計 $O(N)$ ＋ 出現値の個数分ループ（最大でも $N$）なので **$O(N)$**
* 空間計算量：頻度を格納するためのハッシュマップまたは配列で **$O(N)$**

---

### 実装上の注意点

* 出現回数 $cnt[v]$ が大きい場合、
  $$\binom{cnt[v]}{2} \times (N - cnt[v])$$
  の計算で 64bit 整数が溢れる可能性があるため、大きめの整数型（Rust なら `u128`／C++ なら `long long` や `__int128`）を使うのが安全。
* 値の範囲が「1〜$N$」なので、頻度を格納する配列を `Vec<usize>` 長さ $(N+1)$ で用意することも可能で、HashMap より高速に動作する。
* $cnt[v] < 2$ の場合、$\binom{cnt[v]}{2} = 0$ なのでスキップしても OK。
* 入力が大きいので、I/O を速くする配慮（Rust なら `read_to_string`＋`split_whitespace`、C++ なら `ios::sync_with_stdio(false)`, `cin.tie(nullptr)` 等）をしておく。

---

### 要約表

| 項目     | 内容                                                  |
| ------ | --------------------------------------------------- |
| 分類     | 組み合わせ数え上げ・頻度集計                                      |
| アルゴリズム | 値ごとの出現回数を集計 → $\binom{cnt}{2} \times (N - cnt)$ を合計 |
| 時間計算量  | $O(N)$                                              |
| 空間計算量  | $O(N)$                                              |
| キーアイデア | 「同じ値を2つ選ぶ」×「異なる値を1つ選ぶ」という分割による効率化                   |

---

## 全体の振り返り

* A 問題は基本的な条件分岐練習。
* B 問題はループ・総和・条件判定の組み合わせで、Rust のベクタ処理やイテレータ操作に慣れるのに適している。
* どちらもシンプルだが、Rust の構文に慣れる上で非常に良い題材。
