#競技プログラミング #AtCoder #ABC431

---

## A - Robot Balance

### 問題概要

高橋くんは、頭パーツの重さ $H$、体パーツの重さ $B$ を持っている。
ロボットが倒れないためには「頭パーツの重さ $\leq$ 体パーツの重さ」である必要がある。
倒れないようにするために、体パーツをあと何グラム重くすべきか求める。

### 解法設計

ロボットが倒れない条件は $B \geq H$ である。したがって、必要な追加重量は $\max(0, H - B)$ となる。

### 計算量評価

* 時間計算量: $O(1)$
* 空間計算量: $O(1)$

---

## B - Robot Weight

### 問題概要

重さ $X$ のロボットに、$N$ 種類の部品（それぞれの重さ $W_i$）を取り付けたり外したりする操作が $Q$ 回与えられる。
各操作のたびに現在のロボットの重さを出力する。

### 解法設計

* 各部品の取り付け状態を boolean 配列で管理する。
* クエリ $P_i$ ごとに装着／取り外しをトグルし、重さを更新して出力する。

### 計算量評価

* 時間計算量: $O(Q)$
* 空間計算量: $O(N)$

---

## C - Robot Factory

### 問題概要

頭パーツ $N$ 個、体パーツ $M$ 個があり、それぞれ重さが配列 $H, B$ で与えられる。
倒れないロボット（頭 $\leq$ 体）を $K$ 体作れるか判定する。

### 初期アプローチ（TLE原因）

初期実装では、貪欲に組み合わせを作る際に `Vec::remove()` を使用していたため、
削除操作のたびに $O(N)$ のシフトが発生し、最悪 $O(NM)$ でTLE。

### 改善アプローチ（二重ポインタ法）

* $H$ と $B$ を降順ソート。
* 2つのポインタを進めながら、条件 $H_i \leq B_j$ を満たすペアを貪欲に構築。

### 計算量評価

| 処理    | 計算量                 |
| ----- | ------------------- |
| ソート   | $O((N+M)\log(N+M))$ |
| マッチング | $O(N+M)$            |
| 合計    | $O((N+M)\log(N+M))$ |

---

## D - Robot Customize

### 問題概要

高橋くんは $N$ 種類の部品を、**頭または体**のいずれかに1つずつ取り付けてロボットを作る。
部品 $i$ の重さを $W_i$、頭に取り付けたときの嬉しさを $H_i$、体に取り付けたときの嬉しさを $B_i$ とする。
ロボットが倒れないための条件は「頭の総重量 ≤ 体の総重量」である。

このとき、ロボットを倒さずに得られる**嬉しさの合計の最大値**を求めよ。

### 制約

* $1 \le N \le 500$
* $1 \le W_i \le 500$
* $1 \le H_i, B_i \le 10^9$

---

### 制約分析

最大重さの合計は $500 \times 500 = 2.5 \times 10^5$ であり、
$O(NW)$ のDPが十分実行可能（$500 \times 2.5\times10^5 \approx 1.25\times10^8$）。
メモリも $O(NW)$ で許容（1次元化すればさらに軽量）。

---

### 解法設計（DPによる変換）

まず、各部品の体装着を基準に考える。

* 各部品を体に取り付けたときの「嬉しさ基準値」：$\text{base} = \sum_i B_i$
* 各部品を頭に取り付けた場合の**増分嬉しさ**：$\text{gain}_i = H_i - B_i$

倒れない条件：
$$
\text{頭重量} \le \text{体重量} \
\Rightarrow \text{頭重量} \le \frac{\text{総重量}}{2}
$$

したがって「頭に載せる部品の重さ合計を $\le \text{limit} = \frac{\text{総重量}}{2}$ に制限した上で、嬉しさの増分を最大化する」問題に変換できる。

---

### DP定義

#### 状態定義

$$
dp[i][j] = i\text{番目まで見て}, 頭に載せた総重量が \}j\text{のときの最大gain}
$$

#### 遷移

* 部品$i$を頭にしない： $dp[i+1][j] = \max(dp[i+1][j], dp[i][j])$
* 部品$i$を頭にする： $dp[i+1][j+W_i] = \max(dp[i+1][j+W_i], dp[i][j] + gain_i)$

#### 初期化

$$
dp[0][0] = 0
$$

#### 最終解

$$
\text{ans} = \text{base} + \max_{j \le limit} dp[N][j]
$$

---

### 計算量評価

| 項目    | 内容                           |
| ----- | ---------------------------- |
| 時間計算量 | $O(NW)$                      |
| 空間計算量 | $O(NW)$（ただし1次元DPで$O(W)$に削減可） |

---

### 実装上の注意点

* `limit = (sum_w / 2)` を整数除算で計算する（小数不可）。
* DP配列の初期化では `dp[0][0] = 0` を忘れない。
* 1次元DP化では更新を**逆順ループ**で行うこと（典型的ナップサック最適化）。

---

### 要約表

| 項目   | 内容                                                |
| ---- | ------------------------------------------------- |
| 分類   | ナップサックDP                                          |
| 状態   | 頭に載せた重さと得られるgain                                  |
| 遷移   | `dp[i+1][j+w] = max(dp[i+1][j+w], dp[i][j]+gain)` |
| 制約条件 | 頭重量 ≤ 体重量                                         |
| 最終解  | `sum_b + max(dp[N][j])`                           |
| 計算量  | $O(NW)$                                           |
| 最適化  | 1次元DPで $O(W)$ に削減可能                               |

---

## 総括

| 問題 | 分類       | 主要アルゴリズム   | 計算量                 | 注意点                 |
| -- | -------- | ---------- | ------------------- | ------------------- |
| A  | 条件分岐     | 比較演算       | $O(1)$              | 単純比較                |
| B  | シミュレーション | 状態トグル管理    | $O(Q)$              | 状態更新のトグル            |
| C  | 貪欲法      | ソート＋二重ポインタ | $O((N+M)\log(N+M))$ | `Vec::remove()` は禁止 |
| D  | 動的計画法    | ナップサックDP   | $O(NW)$             | 初期化・逆順更新に注意         |

