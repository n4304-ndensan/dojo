# PW_Crack_3 Writeup

## 概要

与えられたスクリプトはユーザーパスワードのMD5ハッシュを既知のハッシュと比較し、一致した場合に暗号化されたフラグファイルを簡易XORで復号して表示するチャレンジである。

## ファイル構成（想定）

* `pw_crack_3.py`（提示されたスクリプト）
* `level3.flag.txt.enc`（暗号化されたフラグ）
* `level3.hash.bin`（正解パスワードのMD5ダイジェスト）

## 問題の読み取りと設計方針

1. スクリプトは入力パスワードを`hash_pw`関数でMD5ダイジェスト化して、`level3.hash.bin`の内容とバイト列比較している。
2. `pos_pw_list`には7つの候補が列挙されており、正解はそのうちの1つである。
3. 正解が判明したら`str_xor`関数で`level3.flag.txt.enc`を復号してフラグを取得する。

したがって実装方針は以下である。

* 7つの候補それぞれについてMD5ダイジェストを計算し、`level3.hash.bin`と比較する。
* 一致した候補が見つかったら、同じパスワードで`str_xor`と同等の処理を行い、フラグを復号する。

## 重要な実装詳細（解析）

* `hash_pw`はパスワード文字列をUTF-8（スクリプトは `encode()` を使っている）でエンコードしたバイト列に対して`hashlib.md5()`を適用し、`digest()`（16バイト）を返す。
* `level_3_pw_check`はバイナリ比較（`==`）を行うため、ファイル`level3.hash.bin`はMD5の生バイト（16バイト）で保存されていることが前提である。
* `str_xor(secret, key)`は`key`を`secret`長まで繰り返し拡張し、対応する文字同士のUnicodeコードポイント（`ord`）でXOR演算を行い、その結果を文字列として結合している。要点は`key`の繰り返し拡張が**1文字ずつ**appendされる形で行われ、単純な繰り返し（`key * (len(secret)//len(key)) + key[:...]`）と等価である点である。

### `str_xor`の振る舞い（要約）

* 引数`secret`は`flag_enc.decode()`として呼ばれている点に注意すること。`flag_enc`がバイナリ（`rb`で読み込んだ結果）であるため、`decode()`はバイト列がデコード可能なテキスト（おそらくASCII互換）であることを前提としている。
* `str_xor`は結果を文字列として返すため、暗号化時に同様の手続きで`secret`側も文字列をXORして生成されている必要がある。

### 実行結果についての注意

* 上記スクリプトは与えられたバイナリファイルの中身に依存するため、この文書では特定のパスワードやフラグ文字列を断言していない。
* 実行環境によっては`flag_enc.decode()`が`UnicodeDecodeError`を投げる可能性がある。オリジナルスクリプトは`flag_enc.decode()`を使っているため、同じ手順でデコードしてからXORする実行を試みるべきである。

## セキュリティ的な所見

* パスワード検証がMD5の平文比較で行われているため、候補が小さい場合はオフラインで総当たりが容易である。
* XORによる単純なストリーム暗号はキーストリームが短い（ここではパスワード長）場合に脆弱である。キーが推測可能な場合は復号が直ちに可能である。

## まとめ（手順の要点）

1. `level3.hash.bin`を16バイトのMD5ダイジェストとして読み込むである。
2. 候補リスト`pos_pw_list`の各要素についてMD5ダイジェストを計算して比較するである。
3. 一致したパスワードを用いて`level3.flag.txt.enc`をデコードし、`str_xor`と同等手順でXOR復号を行うである。

---

作業は以上である。
