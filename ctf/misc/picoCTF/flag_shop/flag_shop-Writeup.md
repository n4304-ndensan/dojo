#CTF #picoCTF #binary #flag_shop

# flag_shop Writeup

## 1. 問題概要

`flag_shop` は 32bit 符号付き整数オーバーフローを悪用し、負値化を利用して残高を増加させ、高額フラグを購入するバイナリ問題である。特に本問題では、オーバーフロー後の値でも number_flags > 0 判定を通過する点が攻略の鍵となる。

## 2. コード構造と脆弱ポイント

### 2.1 問題箇所

```c
int number_flags = 0;
scanf("%d", &number_flags);
if(number_flags > 0){
    int total_cost = 900 * number_flags;
}
```

### 2.2 重要な事実

* scanf("%d") はオーバーフローをチェックしない。
* 32bit の範囲を超える整数を入力すると下位32bitに切り捨てられる。
* 切り捨て後の 32bit の値が正であれば number_flags > 0 を通過する。

## 3. 2 の補数表現とオーバーフロー

### 3.1 32bit 符号付き整数の範囲

* 最小値: -2147483648
* 最大値: 2147483647

範囲外の演算結果は下位32bitだけが残り、最上位ビットが1なら負数として解釈される。

## 4. 実際のオーバーフロー値解析

攻撃で使用した入力:

```
2147483547
```

### 4.1 total_cost の計算

```
900 * 2147483547
```

本来の計算結果は:

```
1932735192300
```

これは 32bit に収まらず丸め込まれる。

### 4.2 下位32bitに切り捨て

切り捨て後の total_cost は実際に:

```
-90900
```

となった。これは下位32bit の最上位ビットが1であったためである。

## 5. なぜ残高が増えるか

```
account_balance = account_balance - total_cost;
```

total_cost が負であるため、実際には加算となり残高が増える。

例:

```
1100 - (-90900) = 92000
```

## 6. number_flags > 0 を通過できる理由

オーバーフロー後の number_flags は、下位32bit がたまたま正の値だったため、number_flags > 0 を通過する。

例: 入力 2147483547 は 32bit に丸めると正の整数として扱われる。

## 7. 手順まとめ

1. number_flags に大きすぎる整数を入力
2. 900 * number_flags がオーバーフローして負数化
3. 残高が加算される
4. 残高を10万以上に増やす
5. 1337 Flag を購入してフラグ入手

## 8. 最終取得フラグ

```
picoCTF{m0n3y_bag5_984Fce5a}
```

## 9. 要約表

| 項目   | 内容                           |
| ---- | ---------------------------- |
| 脆弱性  | 32bit 符号付き整数オーバーフロー          |
| 原因   | 下位32bit切り捨てと MSB の符号解釈       |
| 通過条件 | number_flags が丸め後に正値になる      |
| 効果   | 残高の不正加算                      |
| フラグ  | picoCTF{m0n3y_bag5_984Fce5a} |
| 計算量  | O(1)                         |
