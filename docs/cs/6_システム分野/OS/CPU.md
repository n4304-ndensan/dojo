#OS #CPU #メトリック #パフォーマンス測定

CPU（Central Processing Unit）は、コンピュータの中枢であり、演算や制御を担う最も重要なハードウェア要素である。このドキュメントでは、CPUの基礎（vCPU・クロック・キャッシュ構造）から、CPUメトリック（使用率・時間・ステート）までを体系的に整理し、実運用での見方をまとめる。

---

## 1. CPUの基礎構造と動作

### vCPU（仮想CPU）

- **定義**：仮想マシンやコンテナで割り当てられる**論理的なCPUコア**。
    
- **関係**：1物理コア = 複数のvCPU（ハイパースレッディングなど）。
    
- **例**：
    
    - 4コア8スレッドCPU → vCPU8個。
        
    - VMに2vCPUを割り当てると2コア相当の性能。
        

### クロック数（周波数）

- **定義**：CPUが1秒間に命令を処理できる回数（Hz単位）。
    
- **特徴**：
    
    - 高クロック＝高速だが高消費電力。
        
    - 実効性能はキャッシュ・パイプライン設計にも依存。
        
    - CPUは動的にクロックを調整（Turbo Boost、省電力モード）。
        

### キャッシュ構造（L1 / L2 / L3）

|層|特徴|容量|共有範囲|
|---|---|---|---|
|L1|最速（数サイクル）・最小。命令とデータで分離。|数十KB|各コア専用|
|L2|中速・中容量。L1より遅い。|数百KB〜1MB|各コア専用|
|L3|大容量・最も遅いが全体共有。|数MB〜数十MB|全コア共有|

> キャッシュヒット率が高いほど性能は向上。L1→L2→L3→メモリの順に遅延が増加する。

### スケジューリング

- OSスケジューラが複数プロセスをCPUに割り当てる。
    
- 共有状況により、1プロセスへのCPU時間は変動。
    
- 仮想環境では、ホスト側でのスケジューリング競合により**steal time**（他VMに奪われるCPU時間）が発生する。
    

---

## 2. CPUメトリック

CPUメトリックはCPUの活動状況を定量化したもので、パフォーマンス診断の基本となる。

### 2.1 CPU使用率（CPU Utilization）

- **式**：`CPU使用率 = (CPU稼働時間 / CPU総時間) × 100%`
    
- **CPU稼働時間**とは：CPUが実際に命令を実行していた時間（user + system + nice などの合計）。
    
- **高いとき**：CPU飽和（90%以上が継続）。
    
- **低いとき**：I/O待機やスレッドブロックの可能性。
    

#### 他プロセス・別環境での影響

- CPU使用率は**相対的な指標**であり、同じアプリケーションでもCPU性能・同時実行プロセス数・仮想環境の影響によって大きく変わる。
    
- 他プロセスがCPUを多く消費していると、OSスケジューラがCPU時間を分配するため、**CPU使用率は相対的に低下**する。
    
- 仮想環境では、ホストOS上の他VMの負荷によって**steal time**が増加し、見かけ上の使用率が下がる。
    
- したがって、CPU使用率は**「その時点の環境に依存した相対的な値」**であり、異なる環境での比較には不向き。
    

---

### 2.2 CPU時間（CPU Time）

CPU時間はCPUが実際に命令を実行した**絶対的な処理時間**を示す。

- **User Time（utime）**：ユーザ空間での実行。
    
- **System Time（stime）**：カーネル空間での実行。
    
- **Children User/System（cutime/cstime）**：子プロセスの累積時間。
    

#### 特徴

- I/Oや他プロセスの影響を受けにくい。
    
- 単独実行時は経過時間に近く、CPU使用率は理論上100%。
    
- マルチスレッドではスレッド数に比例して加算され、経過時間を超える場合あり。
    
- クロック変動（省電力モード・Turbo Boost）で進行速度が一定でないこともある。
    
- **CPU稼働時間**とは、プロセスが実際にCPU上で実行されていた時間（user + system）を指す。待機中やI/O待ちは含まれない。
    

#### 他プロセス・別環境での影響

- CPU時間は基本的に**他プロセスや外部負荷の影響を受けにくい**。ただし、CPUが他プロセスに時間を割り当てている間は自プロセスのCPU時間の進行が遅くなる。
    
- CPUの性能（クロック数・キャッシュ効率）が異なる環境では、**同じCPU時間でも実行に要する現実時間（wall clock time）は異なる**。
    
- 仮想環境ではホスト側スケジューリングの影響で、CPU時間の増加が断続的になることがある。
    

#### 例

- プロセスA：`User=12s`, `System=3s` → 合計15s。
    
- 経過時間60s → `%CUU = 15/60 × 100 = 25%`（60はプロセスの経過時間であり、CPU総動作時間ではない）。
    
- 子プロセス時間9s → `%CUC = (15+9)/60 × 100 = 40%`。
    

> I/Oがなく他プロセスが動いていない環境では、CPUTime ≒ 経過時間 → CPU使用率 ≈ 100%。

---

### 2.3 CPUステート（CPU States）

CPUステートはCPU時間の内訳を示し、どの処理にCPUリソースが費やされているかを明確にする。

|ステート|意味|増える状況|
|---|---|---|
|user|ユーザ空間での処理|計算・圧縮・暗号化など演算集中処理|
|system|カーネル空間の処理|ファイルI/O・システムコール・ネット通信|
|nice|優先度を下げた処理|バックグラウンド・低優先度ジョブ|
|idle|アイドル時間|処理が少ない・CPU待機状態|
|iowait|I/O待機|ディスク・ネットワーク遅延|
|irq / softirq|割り込み処理|ネットワークパケット・デバイス操作多発|
|steal|他VMに奪われた時間|仮想化環境でリソース競合時|

---

## 3. CPU性能評価の観点

CPUの性能評価を行う上では、以下のメトリックを中心に観察することで、CPUの使われ方やボトルネックをおおむね把握できる。

- `cputime(system)`：カーネル処理時間。ファイルI/Oやネットワーク、システムコールが多いと増加。
    
- `cputime(user)`：アプリケーションの処理時間。演算処理が多いと上昇。
    
- `iowait`：I/O待ち時間。ストレージ遅延やネットワーク待機で上昇。
    
- `irq` / `softirq`：デバイスやネットワーク割り込み時間。大量通信やデバイスI/O集中で上昇。
    

これらを組み合わせて分析することで、CPUがどの要因に時間を費やしているかを正確に評価できる。#OS #CPU #メトリック #パフォーマンス測定

# CPUまとめドキュメント

CPU（Central Processing Unit）は、コンピュータの中枢であり、演算や制御を担う最も重要なハードウェア要素である。このドキュメントでは、CPUの基礎（vCPU・クロック・キャッシュ構造）から、CPUメトリック（使用率・時間・ステート）までを体系的に整理し、実運用での見方をまとめる。

---

## 1. CPUの基礎構造と動作

### vCPU（仮想CPU）

- **定義**：仮想マシンやコンテナで割り当てられる**論理的なCPUコア**。
    
- **関係**：1物理コア = 複数のvCPU（ハイパースレッディングなど）。
    
- **例**：
    
    - 4コア8スレッドCPU → vCPU8個。
        
    - VMに2vCPUを割り当てると2コア相当の性能。
        

### クロック数（周波数）

- **定義**：CPUが1秒間に命令を処理できる回数（Hz単位）。
    
- **特徴**：
    
    - 高クロック＝高速だが高消費電力。
        
    - 実効性能はキャッシュ・パイプライン設計にも依存。
        
    - CPUは動的にクロックを調整（Turbo Boost、省電力モード）。
        

### キャッシュ構造（L1 / L2 / L3）

|層|特徴|容量|共有範囲|
|---|---|---|---|
|L1|最速（数サイクル）・最小。命令とデータで分離。|数十KB|各コア専用|
|L2|中速・中容量。L1より遅い。|数百KB〜1MB|各コア専用|
|L3|大容量・最も遅いが全体共有。|数MB〜数十MB|全コア共有|

> キャッシュヒット率が高いほど性能は向上。L1→L2→L3→メモリの順に遅延が増加する。

### スケジューリング

- OSスケジューラが複数プロセスをCPUに割り当てる。
    
- 共有状況により、1プロセスへのCPU時間は変動。
    
- 仮想環境では、ホスト側でのスケジューリング競合により**steal time**（他VMに奪われるCPU時間）が発生する。
    

---

## 2. CPUメトリック

CPUメトリックはCPUの活動状況を定量化したもので、パフォーマンス診断の基本となる。

### 2.1 CPU使用率（CPU Utilization）

- **式**：`CPU使用率 = (CPU稼働時間 / CPU総時間) × 100%`
    
- **CPU稼働時間**とは：CPUが実際に命令を実行していた時間（user + system + nice などの合計）。
    
- **高いとき**：CPU飽和（90%以上が継続）。
    
- **低いとき**：I/O待機やスレッドブロックの可能性。
    

#### 他プロセス・別環境での影響

- CPU使用率は**相対的な指標**であり、同じアプリケーションでもCPU性能・同時実行プロセス数・仮想環境の影響によって大きく変わる。
    
- 他プロセスがCPUを多く消費していると、OSスケジューラがCPU時間を分配するため、**CPU使用率は相対的に低下**する。
    
- 仮想環境では、ホストOS上の他VMの負荷によって**steal time**が増加し、見かけ上の使用率が下がる。
    
- したがって、CPU使用率は**「その時点の環境に依存した相対的な値」**であり、異なる環境での比較には不向き。
    

---

### 2.2 CPU時間（CPU Time）

CPU時間はCPUが実際に命令を実行した**絶対的な処理時間**を示す。

- **User Time（utime）**：ユーザ空間での実行。
    
- **System Time（stime）**：カーネル空間での実行。
    
- **Children User/System（cutime/cstime）**：子プロセスの累積時間。
    

#### 特徴

- I/Oや他プロセスの影響を受けにくい。
    
- 単独実行時は経過時間に近く、CPU使用率は理論上100%。
    
- マルチスレッドではスレッド数に比例して加算され、経過時間を超える場合あり。
    
- クロック変動（省電力モード・Turbo Boost）で進行速度が一定でないこともある。
    
- **CPU稼働時間**とは、プロセスが実際にCPU上で実行されていた時間（user + system）を指す。待機中やI/O待ちは含まれない。
    

#### 他プロセス・別環境での影響

- CPU時間は基本的に**他プロセスや外部負荷の影響を受けにくい**。ただし、CPUが他プロセスに時間を割り当てている間は自プロセスのCPU時間の進行が遅くなる。
    
- CPUの性能（クロック数・キャッシュ効率）が異なる環境では、**同じCPU時間でも実行に要する現実時間（wall clock time）は異なる**。
    
- 仮想環境ではホスト側スケジューリングの影響で、CPU時間の増加が断続的になることがある。
    

#### 例

- プロセスA：`User=12s`, `System=3s` → 合計15s。
    
- 経過時間60s → `%CUU = 15/60 × 100 = 25%`（60はプロセスの経過時間であり、CPU総動作時間ではない）。
    
- 子プロセス時間9s → `%CUC = (15+9)/60 × 100 = 40%`。
    

> I/Oがなく他プロセスが動いていない環境では、CPUTime ≒ 経過時間 → CPU使用率 ≈ 100%。

---

### 2.3 CPUステート（CPU States）

CPUステートはCPU時間の内訳を示し、どの処理にCPUリソースが費やされているかを明確にする。

|ステート|意味|増える状況|
|---|---|---|
|user|ユーザ空間での処理|計算・圧縮・暗号化など演算集中処理|
|system|カーネル空間の処理|ファイルI/O・システムコール・ネット通信|
|nice|優先度を下げた処理|バックグラウンド・低優先度ジョブ|
|idle|アイドル時間|処理が少ない・CPU待機状態|
|iowait|I/O待機|ディスク・ネットワーク遅延|
|irq / softirq|割り込み処理|ネットワークパケット・デバイス操作多発|
|steal|他VMに奪われた時間|仮想化環境でリソース競合時|

---

## 3. CPU性能評価の観点

CPUの性能評価を行う上では、以下のメトリックを中心に観察することで、CPUの使われ方やボトルネックをおおむね把握できる。

- `cputime(system)`：カーネル処理時間。ファイルI/Oやネットワーク、システムコールが多いと増加。
    
- `cputime(user)`：アプリケーションの処理時間。演算処理が多いと上昇。
    
- `iowait`：I/O待ち時間。ストレージ遅延やネットワーク待機で上昇。
    
- `irq` / `softirq`：デバイスやネットワーク割り込み時間。大量通信やデバイスI/O集中で上昇。
    

これらを組み合わせて分析することで、CPUがどの要因に時間を費やしているかを正確に評価できる。
