# アセンブリ言語（x86-64）入門

## 基本構文

x86-64 のアセンブリ命令は概ね

```asm
命令名  宛先オペランド, ソースオペランド
; コメント
```

という形式で記述する。

* **オペコード（opcode）**: `add`, `mov`, `jmp` など命令名そのもの。
* **オペランド（operand）**: 命令の入力・出力となる値。

  * レジスタ: `rax`, `rbx` など
  * メモリ: `[0x602060]`, `[rdi]` など
  * 即値: `1`, `10`, `0x15` など

宛先オペランドが左（書き込まれる側）、ソースオペランドが右（読み出す側）である。

---

## データサイズ指定

x86-64 では同じ命令でも扱うデータサイズを **接頭辞** で指定する。

| 記法      | 意味          | サイズ          |
| ------- | ----------- | ------------ |
| `QWORD` | Quad Word   | 8バイト (64bit) |
| `DWORD` | Double Word | 4バイト (32bit) |
| `WORD`  | Word        | 2バイト (16bit) |
| `BYTE`  | Byte        | 1バイト (8bit)  |

メモリオペランドに対しては `QWORD PTR`, `DWORD PTR` のように `PTR` を付けて「指定サイズのポインタ」を示す。

---

## データ転送命令 `mov`

### 即値 -> レジスタ

```asm
mov rax, 1          ; rax に即値 1 を代入
mov dl, 0x15        ; dl の下位8bitが 0x15 になる
; 例: dx = 0x1234 のとき dl = 0x15 になると dx は 0x1215 となる
```

### レジスタ <-> レジスタ

```asm
mov rax, rbx        ; rbx の値を rax にコピー
```

### メモリ -> レジスタ

```asm
mov rax, QWORD PTR [0x602060]   ; メモリ 0x602060 から8バイト読み取り rax に格納
mov eax, DWORD PTR [0x602060]   ; 4バイト読み取り eax に格納
```

### レジスタ -> メモリ

```asm
mov QWORD PTR [rdi], rdx        ; rdx の値を [rdi] が指す8バイト領域へ書き込む
```

### 符号拡張/ゼロ拡張 `movsx`, `movzx`

```asm
movsx rax, eax      ; eax を符号拡張して rax へ
movzx rax, eax      ; eax をゼロ拡張して rax へ
```

---

## 有効アドレス計算 `lea`

```asm
lea rax, [rax + rcx*8]
```

* `lea` は **メモリを読み出さず**，括弧内のアドレス計算結果そのものをレジスタに入れる。
* `mov rax, [rax + rcx*8]` なら「そのアドレスにある値」を読み込む点が異なる。

---

## 算術命令

### 加算・減算

```asm
add rax, 10     ; rax += 10
add a, b        ; a = a + b

sub a, b        ; a = a - b
inc a           ; a = a + 1
dec a           ; a = a - 1
```

### 乗算 `mul`（符号なし）

```asm
; 7 * 3 の例
mov rax, 7
mov rcx, 3
mul rcx         ; RAX * RCX → RDX:RAX に格納（下位が RAX）
```

### 除算 `div`（符号なし）

```asm
mov rax, 21
mov rdx, 0      ; 上位ビットは 0 にしておく
mov rcx, 5
div rcx         ; (RDX:RAX) / RCX → 商が RAX, 余りが RDX
```

### 符号付き乗除算 `imul`, `idiv`

```asm
imul rcx        ; 符号付き乗算
idiv rcx        ; 符号付き除算
```

---

## 論理・ビット演算

```asm
and rax, rbx    ; 論理積
or  rax, rbx    ; 論理和
xor rax, rbx    ; 排他的論理和
not rax         ; ビット反転
```

---

## シフト命令

```asm
shl rax, 1      ; rax <<= 1
shr rax, 1      ; rax >>= 1 （論理右シフト）
```

可変シフト量は `cl` レジスタに入れる。

```asm
mov cl, 3
shl rax, cl     ; rax <<= 3
shr rax, 17     ; 即値 17 だけ右シフト
```

---

## 比較とフラグレジスタ

### `cmp` と `test`

```asm
cmp A, B        ; A - B を内部的に計算し，結果は捨ててフラグだけを更新
test rax, rax   ; rax & rax を計算（ゼロかどうか調べる用途）
```

### フラグレジスタ（FLAGS）の代表

* **ZF (Zero Flag)**: 結果が 0 なら 1
* **SF (Sign Flag)**: 結果の最上位ビット（符号ビット）
* **CF (Carry Flag)**: 桁あふれ（符号なし演算）時に 1
* **OF (Overflow Flag)**: 符号付き演算でのオーバーフロー時に 1

---

## 条件分岐とジャンプ

### 無条件ジャンプ

```asm
jmp label01
; ...
label01:
```

### 条件付きジャンプ

`cmp` / `test` 等でフラグをセットした後に使用する。

```asm
jz   label   ; ZF = 1 のとき Jump if Zero
je   label   ; Jump if Equal（実質 jz と同じ）
jnz  label   ; ZF = 0 のとき Jump if Not Zero
jne  label   ; Jump if Not Equal（実質 jnz と同じ）

ja   label   ; CF=0 かつ ZF=0 のとき（符号なしで A > B）
jae  label   ; CF=0 のとき（A >= B, unsigned）
jb   label   ; CF=1 のとき（A < B, unsigned）
jbe  label   ; CF=1 または ZF=1（A <= B, unsigned）

jg   label   ; ZF=0 かつ SF=OF（A > B, signed）
jge  label   ; SF=OF（A >= B, signed）
jl   label   ; SF≠OF（A < B, signed）
jle  label   ; ZF=1 または SF≠OF（A <= B, signed）
```

関数への単純な分岐に `jmp func` が用いられることもある。

---

## スタック操作

スタックポインタレジスタ: **`rsp`**

```asm
push rax    ; rsp を 8 減算して，その位置に rax を保存
pop rax     ; rsp の位置から値を読み出し rax に格納し，rsp を 8 加算
```

### サブルーチン呼び出し

```asm
call func   ; 次の命令アドレスをスタックに push してから func へ jmp
; ...
func:
    ; 処理
    ret     ; スタックから戻りアドレスを pop し，そこへ戻る
```

`leave` 命令は典型的な関数フレームの後始末を行う。

```asm
; 通常のエピローグ
mov rsp, rbp
pop rbp
ret

; 上と等価
leave
ret
```

`call` 前の `rsp` が「元アドレス」として戻り先に利用される。

---

## システムコール

Linux x86-64 では `syscall` 命令でカーネル機能（キーボード入力，ファイル読み書き等）を呼び出す。

* `rax`: システムコール番号
* 他のレジスタ: 引数（`rdi`, `rsi`, `rdx`, …）

```asm
mov rax, 1      ; write システムコール番号（例）
; rdi, rsi, rdx に引数をセット
syscall
```

---

## コメント

行中の `;` 以降はコメントとして無視される。

```asm
mov rax, 1      ; ここはコメント
```
