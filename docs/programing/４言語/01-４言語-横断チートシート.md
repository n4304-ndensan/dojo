
C# / Rust / Python / TypeScript を同順で並べ、最小で実務的な等価コードを対比する。表やコード例は「読みやすさ」「誤解しやすい差分の明確化」を優先する。

---

## 1. 言語概要比較

|言語|主な特徴|型付け|パラダイム|主な用途|
|---|---|---|---|---|
|C#|Microsoft 製の静的型付け言語。LINQ、async/await、豊富な標準 API。|静的・強い|OOP + FP|業務アプリ、Web、クラウド、ゲーム|
|Rust|所有権・借用によるメモリ安全と高性能。GC なし。|静的・強い|システム指向 + FP|システム、CLI、組込み、WASM|
|Python|動的・簡潔。標準が充実。|動的|FP + OOP + 手続き|AI、データ分析、スクリプト、Web|
|TypeScript|JS に型を導入。ブラウザ／Node 双方で有用。|静的（実行時は JS）|FP + OOP|Web フロント、Node、API|

---

## 2. 基本文法の最小要素

### 2.1 変数・定数

C#（型推論/明示）

```csharp
var x = 10;        // 推論: int
int y = 20;        // 明示
const int A = 1;   // コンパイル時定数
```

Rust（不変が既定／可変は `mut`）

```rust
let x = 10;        // 不変, i32 推論
let mut y = 20;    // 可変
const A: i32 = 1;  // コンパイル時定数
```

Python（動的）

```python
x = 10
A = 1  # 慣習的に大文字で定数扱い
```

TypeScript（`let`/`const`）

```ts
let x = 10;           // number 推論
const A = 1;         // 再代入不可
```

### 2.2 算術・比較・論理（要点のみ）

| 区分      | C#                                                             | Rust                                                          | Python                                                         | TypeScript                                                                 |
| ------- | -------------------------------------------------------------- | ------------------------------------------------------------- | -------------------------------------------------------------- | -------------------------------------------------------------------------- |
| 加減乗除    | a + b / a - b / a * b / a / b                                  | a + b / a - b / a * b / a / b                                 | a + b / a - b / a * b / a / b                                  | a + b / a - b / a * b / a / b                                              |
| 余り      | a % b                                                          | a % b                                                         | a % b                                                          | a % b                                                                      |
| 累乗      | Math.Pow(a, b)                                                 | a.pow(b)（数値型の pow）                                            | a ** b                                                         | a ** b                                                                     |
| 等価      | a == b                                                         | a == b                                                        | a == b                                                         | a === b（推奨）                                                                |
| 否定（NOT） | !a                                                             | !a（bool）、整数のビット反転も !a                                         | not a                                                          | !a                                                                         |
| AND/OR  | AND: a && b <br>OR: a \|\| b                                   | AND: a && b <br>OR: a \|\| b                                  | AND: a and b  <br>OR: a or b                                   | AND: a && b <br>OR: a \|\| b                                               |
| ビット演算   | AND: a & b <br>OR: a \| b <br>XOR: a ^ b <br>NOT: ~a <br><< >> | AND: a & b <br>OR: a \| b <br>XOR: a ^ b<br>NOT: !a <br><< >> | AND: a & b <br>OR: a \| b <br>XOR: a ^ b <br>NOT: ~a <br><< >> | AND: a & b <br>OR: a \| b <br>XOR: a ^ b <br>NOT: ~a <br><< >>（さらに >>> あり） |

注記: Rust のビット否定は `!x`。論理否定も `!bool` で表す。TypeScript のビット否定は `~x`。C# のビット否定は `~x`。Python は `~x`。

### 2.3 条件式と三項

C#

```csharp
var y = cond ? "ok" : "ng";
```

Rust（式）

```rust
let y = if cond { "ok" } else { "ng" };
```

Python

```python
y = "ok" if cond else "ng"
```

TypeScript

```ts
const y = cond ? "ok" : "ng";
```

### 2.4 真偽値・存在チェック

|判定|C#|Rust|Python|TypeScript|
|---|---|---|---|---|
|null/None|`x == null`|`x.is_none()`（`Option`）|`x is None`|`x == null` / `x === undefined`|
|非 null|`x != null`|`x.is_some()`|`x is not None`|`x != null`|

---

## 3. 条件分岐

C#

```csharp
if (x > 5) { }
else if (x < 3) { }
else { }
```

Rust

```rust
if x > 5 { }
else if x < 3 { }
else { }
```

Python

```python
if x > 5:
    pass
elif x < 3:
    pass
else:
    pass
```

TypeScript

```ts
if (x > 5) { }
else if (x < 3) { }
else { }
```

---

## 4. ループ構文

C#

```csharp
// 基本
for (int i = 0; i < 5; i++) { }
foreach (var v in new[]{1,2,3}) { }
while (cond) { }

// 部分範囲（配列スライス .NET 5+）
var a = new[] {1,2,3,4,5};
foreach (var v in a[1..4]) { }  // 2,3,4

// ステップ（間引き）
for (int i = 0; i < a.Length; i += 2) { }  // 0,2,4,...

// リバース
for (int i = a.Length - 1; i >= 0; i--) { }   // 逆順 index
foreach (var v in a.AsSpan().ToArray().Reverse()) { } // 値で逆順
```

Rust

```rust
// 基本
for i in 0..5 { }
for v in [1,2,3] { let _ = v; }
let mut n = 0; while n < 3 { n += 1; }
for i in (0..5).rev() { } // 逆順レンジ

// 部分範囲（スライス）
let a = [1,2,3,4,5];
for &v in &a[1..4] { } // 2,3,4（&で借用、&vでコピー取得）

// ステップ（間引き）
for i in (0..10).step_by(2) { } // 0,2,4,6,8

// リバース（コレクション）
for v in a.iter().rev() { } // 5,4,3,2,1（参照で逆順）
```

Python

```python
# 基本
for i in range(5):
    pass
for v in [1,2,3]:
    pass
n = 0
while n < 3:
    n += 1

# 部分範囲（スライス）
a = [1,2,3,4,5]
for v in a[1:4]:
    pass  # 2,3,4

# ステップ（間引き）
for i in range(0, 10, 2):
    pass  # 0,2,4,6,8

# リバース
for i in reversed(range(5)):
    pass  # 4,3,2,1,0
for v in reversed(a):
    pass  # 5,4,3,2,1
```

---

### TypeScript

```ts
// 基本
for (let i = 0; i < 5; i++) {}
for (const v of [1,2,3]) {}
let n = 0; while (n < 3) { n++; }

// 部分範囲（スライス）
const a = [1,2,3,4,5];
for (const v of a.slice(1, 4)) {} // 2,3,4

// ステップ（間引き）
for (let i = 0; i < a.length; i += 2) {} // 0,2,4,...

// リバース
for (let i = a.length - 1; i >= 0; i--) {}     // indexで逆順
for (const v of [...a].reverse()) {}           // 値で逆順（元配列は不変）
```

---

## 5. 関数（無名含む）

C#

```csharp
int Add(int a, int b) => a + b;
var f = (int x) => x * 2;
```

Rust

```rust
fn add(a: i32, b: i32) -> i32 { a + b }
let f = |x: i32| x * 2;
```

Python

```python
def add(a: int, b: int) -> int:
    return a + b
f = lambda x: x * 2
```

TypeScript

```ts
function add(a: number, b: number): number { return a + b; }
const f = (x: number) => x * 2;
```

---

## 6. クラス／構造体／メソッド

C#（クラス）

```csharp
class Person
{
    public string Name;
    public Person(string n) { Name = n; }
    public void Say() => Console.WriteLine(Name);
}
var p = new Person("A");
```

Rust（構造体 + impl）

```rust
struct Person { name: String }
impl Person {
    fn new(name: String) -> Self { Self { name } }
    fn say(&self) { println!("{}", self.name); }
}
let p = Person::new("A".to_string());
```

Python（クラス）

```python
class Person:
    def __init__(self, name: str):
        self.name = name
    def say(self) -> None:
        print(self.name)
p = Person("A")
```

TypeScript（クラス）

```ts
class Person {
  constructor(public name: string) {}
  say() { console.log(this.name); }
}
const p = new Person("A");
```

---

## 7. コレクション操作（最小）

C#

```csharp
var list = new List<int>{1,2,3};
var mapped = list.Select(x => x*2).ToList();
var filtered = list.Where(x => x > 1).ToList();
```

Rust

```rust
let v = vec![1,2,3];
let mapped: Vec<_> = v.iter().map(|x| x*2).collect();
let filtered: Vec<_> = v.iter().cloned().filter(|x| *x > 1).collect();
```

Python

```python
lst = [1,2,3]
mapped = [x*2 for x in lst]
filtered = [x for x in lst if x > 1]
```

TypeScript

```ts
const list = [1,2,3];
const mapped = list.map(x => x*2);
const filtered = list.filter(x => x > 1);
```

---

## 8. 例外・エラーハンドリング

C#

```csharp
try { /* ... */ }
catch (Exception e) { /* ... */ }
finally { /* ... */ }
```

Rust（`Result<T,E>`）

```rust
fn f() -> Result<i32, String> { Ok(1) }
let x = match f() {
    Ok(v) => v,
    Err(e) => { 0 }
};
```

Python

```python
try:
    pass
except Exception as e:
    pass
finally:
    pass
```

TypeScript

```ts
try {
  // ...
} catch (e) {
  // ...
} finally {
  // ...
}
```

---

## 9. 非同期（I/O バウンド最小例）

C#

```csharp
async Task Foo() { await Task.Delay(1000); }
```

Rust（tokio）

```rust
async fn foo() { tokio::time::sleep(std::time::Duration::from_secs(1)).await; }
```

Python（asyncio）

```python
import asyncio
async def foo():
    await asyncio.sleep(1)
```

TypeScript

```ts
async function foo() {
  await new Promise(r => setTimeout(r, 1000));
}
```

---

## 10. よくある落とし穴と対策（抜粋）

- 等価演算子の差異
    
    - TypeScript は `===` を既定で用いる（`==` は型変換あり）。
        
    - C# は参照型に対する `==` の挙動に注意（型ごとに演算子オーバーロードの可能性）。参照同一性は `object.ReferenceEquals(a,b)`。
        
- ビット演算と論理演算の区別
    
    - C#/TS/Python のビット NOT は `~x`。Rust のビット NOT は `!x`（論理も `!` だが型で区別）。
        
- Rust の所有権と分解
    
    - タプル分解は要素の型に従い、`Copy` はコピー、非 `Copy` はムーブ。`(i32,&str)` の分解ではムーブが起きない。
        
- 非同期の効果範囲
    
    - 単一プロセス・単一スレッドで他処理が無い場合、`async` の体感差は小さい。UI スレッドやサーバのスループットで効果が出やすい。
        

---

### 参考リンク

- 詳細な型・修飾子の比較: [[02-４言語-型一覧と修飾子比較]]
    
- 標準操作の早見: [[03-４言語-標準操作チートシート]]
	  
- ファイル I/O 詳細: [[04-４言語-ファイル操作まとめ]]
    
- 標準ライブラリ対比: [[11-４言語-標準ライブラリ-代表モジュール-早見表]]
