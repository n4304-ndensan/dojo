
C# / Rust / Python / TypeScript を同順で比較する。型の宣言・変換・階層の考え方、アクセス修飾子や抽象化の違い、継承・インターフェース（trait）対応を横断整理。

---

## 1. 変数・定数の基本構文

### 1.1 型推論による変数定義

C#

```csharp
var x = 10;          // int に推論
var s = "Alice";     // string に推論
```

Rust

```rust
let x = 10;          // i32 に推論（不変）
let mut y = 20;      // 可変にするには mut
```

Python

```python
x = 10               # 動的型付け（型ヒントは省略可）
```

TypeScript

```ts
let x = 10;          // number に推論
const s = "Alice";   // 再代入不可
```

### 1.2 明示的型指定

C#

```csharp
int x = 10;
string name = "Alice";
```

Rust

```rust
let x: i32 = 10;
let name: &str = "Alice";
```

Python

```python
x: int = 10
name: str = "Alice"
```

TypeScript

```ts
let x: number = 10;
let name: string = "Alice";
```

### 1.3 定数

C#

```csharp
const int A = 5;           // コンパイル時定数
readonly double PI = 3.14; // 実行時初期化のみ
```

Rust

```rust
const A: i32 = 5;          // コンパイル時定数
static PI: f64 = 3.14;     // 静的変数（可変にするなら unsafe）
```

Python

```python
A = 5       # 慣習的に大文字で定数扱い
PI = 3.14
```

TypeScript

```ts
const A = 5;               // 再代入不可
```

---

## 2. 代表的な型一覧（抜粋）

|区分|C#|Rust|Python|TypeScript|
|---|---|---|---|---|
|整数|`byte`/`short`/`int`/`long`|`i8..i64`/`u8..u64`/`isize`/`usize`|`int`（任意精度）|`number`（倍精度浮動小数と同型）/`bigint`|
|浮動小数|`float`/`double`/`decimal`|`f32`/`f64`|`float`|`number`|
|文字・文字列|`char`/`string`|`char`/`&str`/`String`|`str`|`string`|
|真偽|`bool`|`bool`|`bool`|`boolean`|
|配列|`T[]`|`[T;N]` 固定長|`list`|`T[]`|
|可変長リスト|`List<T>`|`Vec<T>`|`list`|`Array<T>`|
|連想配列|`Dictionary<K,V>`|`HashMap<K,V>`|`dict`|`Record<K,V>`/`Map<K,V>`|
|集合|`HashSet<T>`|`HashSet<T>`|`set`|`Set<T>`|
|タプル|`(T1,T2,...)`|`(T1,T2,...)`|`tuple`|`[T1,T2,...]`（型レベルタプル）|

詳細は「[[05-４言語-プリミティブ型完全比較]]」を参照。

---

## 3. 型階層・抽象化の考え方

### 3.1 C# の概念

```
object
 ├─ ValueType（int/double/bool/struct...）
 └─ 参照型（string/class/array/delegate/Task...）
```

- `object` が共通基底。`dynamic` は実行時バインディング。
    
- `Nullable<T>` で値型の null 許容（`int?` など）。
    

### 3.2 Rust の概念

```
Any（trait）
 ├─ 具象型（i32/f64/bool/String/Vec<T>...）
 └─ dyn Trait（動的ディスパッチ）
```

- 継承はなく、`trait` による振る舞いの合成。
    
- `impl Trait`（静的）、`dyn Trait`（動的）で抽象化。
    

### 3.3 Python の概念

```
object
 ├─ 組み込み型（int/float/bool/str/list/dict/set/tuple...）
 └─ ユーザ定義 class（多重継承可）
```

- すべて `object` を継承。`bool` は `int` のサブクラス。
    

### 3.4 TypeScript の概念

```
any
 ├─ unknown（安全な最上位）
 │   ├─ number/string/boolean/object/array
 │   └─ null/undefined
 └─ never（到達不能）
```

- 構造的部分型。実行時は JavaScript。
    

---

## 4. 型変換（文字列⇔数値など）

C#

```csharp
int n = int.Parse("42");
string s = n.ToString();
double d = Convert.ToDouble("3.14");
```

Rust

```rust
let n: i32 = "42".parse().unwrap();
let s = n.to_string();
let d: f64 = "3.14".parse().unwrap();
```

Python

```python
n = int("42")
s = str(n)
d = float("3.14")
```

TypeScript

```ts
const n = Number("42");
const s = n.toString();
const d = parseFloat("3.14");
```

---

## 5. ヌル・オプション型の扱い


| 言語         | 記法                                                | 例                                                                        | 備考                                                                                                     |
| ---------- | ------------------------------------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------ |
| C#         | 値型の null 許容: T?<br>参照型の null 許容: string?          | int? x = null; <br>string? s = null;                                     | 参照型の null 許容は「nullable 参照型」を有効にして使う（C# 8+）。合体演算子 ??、条件アクセス ?. あり。                                      |
| Rust       | Option                                            | let x: Option = None; <br>let y = Some(5);                               | match か ? 演算子で扱う。中身を変換する map、既定値 unwrap_or などが定番。                                                      |
| Python     | None（型ヒントは Optional[T] または T \| None）             | x: Optional\[int\] = None <br>y: int \| None = None                      | 判定は is None / is not None を用いる。                                                                        |
| TypeScript | null / undefined とユニオン型（T \| null、T \| undefined） | let x: number \| null = null;<br>let y: number \| undefined = undefined; | strictNullChecks 推奨。x == null は null と undefined の両方を一括判定。オプショナルプロパティ foo?: T、非 null 断言 !、?? と ?. がある。 |

---

## 6. 修飾子（アクセス・抽象・メンバー特性）対応表

|分類|修飾子|説明|C#|Rust|Python|TypeScript|
|---|---|---|:-:|:-:|:-:|:-:|
|アクセス|`public`|外部から参照可|○|○（`pub`）|×|○|
||`protected`|派生クラスから参照可|○|×|×|○|
||`private`|同クラス内のみ|○|○（デフォルト）|×（慣習: `__name`）|○|
||`internal`|同一アセンブリ内|○|×|×|×|
||`pub(crate)`|クレート内公開|×|○|×|×|
|抽象|`abstract`|抽象クラス/メソッド|○|○（trait）|○（ABC）|○|
||`sealed`|継承禁止|○|×|×|○（`final`）|
||`virtual`|オーバーライド可能|○|×|×|○（既定で override 可）|
||`override`|親実装を上書き|○|○（trait 再実装）|○|○|
|契約|`interface`/`trait`|契約定義|○|○（trait）|○（ABC）|○|
|メンバー|`static`|型に属するメンバー|○|○（`impl` 内 `fn` で `self` なし）|○|○|
||`const`|コンパイル時定数|○|○|×|○|
||`readonly`|初期化時のみ代入可|○|×|×|○|
||`async`|非同期|○|○|○|○|
||`unsafe`|安全性無効化|○|○|×|×|

注記:

- Python のアクセス制御は言語機能ではなく慣習（`_`/`__` プレフィックス）。`__name` は名前マングリングで外部から参照しづらくする。
    
- TypeScript の `private`/`protected` はコンパイル時チェック。実行時は JS のオブジェクトであり、ES の `#private` フィールドを使う設計もある。
    
- C# の `internal` と Rust の `pub(crate)` は近い概念。
    

---

## 7. 構文例（修飾子別）

### 7.1 public / private / protected

C#

```csharp
public class User
{
    private int x = 10;
    protected void Show() => Console.WriteLine(x);
}
```

Rust

```rust
pub struct User { x: i32 }   // フィールドはデフォルト非公開
impl User {
    pub fn show(&self) { println!("{}", self.x); }
}
```

Python

```python
class User:
    def __init__(self):
        self.__x = 10  # マングリング（外部から参照困難）
    def _hint(self):
        pass
```

TypeScript

```ts
class User { // デフォルト public
  private x = 10;
  protected show() { console.log(this.x); }
}
```

### 7.2 abstract / interface / trait

C#

```csharp
abstract class Shape { public abstract double Area(); }
interface IWalk { void Walk(); }
class Circle : Shape, IWalk {
    public override double Area() => Math.PI * 3 * 3;
    public void Walk() {}
}
```

Rust

```rust
trait Shape { fn area(&self) -> f64; }
struct Circle { r: f64 }
impl Shape for Circle { fn area(&self) -> f64 { std::f64::consts::PI * self.r * self.r } }
```

Python

```python
from abc import ABC, abstractmethod
class Shape(ABC):
    @abstractmethod
    def area(self) -> float: ...
class Circle(Shape):
    def area(self) -> float:
        return 3.14159 * 3 * 3
```

TypeScript

```ts
abstract class Shape { abstract area(): number; }
interface IWalk { walk(): void; }
class Circle extends Shape implements IWalk {
  area(): number { return Math.PI * 3 * 3; }
  walk(): void {}
}
```

### 7.3 static / const / readonly

C#

```csharp
class Counter
{
    public static int Count = 0;
    public static void Inc() => Count++;
}
```

Rust

```rust
impl Counter {
    fn inc() -> i32 {
        static mut COUNT: i32 = 0;
        unsafe { COUNT += 1; COUNT }
    }
}
```

Python

```python
class Counter:
    count = 0
    @staticmethod
    def inc():
        Counter.count += 1
```

TypeScript

```ts
class Counter {
  static count = 0;
  static inc() { Counter.count++; }
}
```

### 7.4 async / unsafe

C#

```csharp
async Task Foo() { await Task.Delay(1000); }
unsafe { int x = 10; int* p = &x; *p = 42; }
```

Rust

```rust
async fn foo() { tokio::time::sleep(std::time::Duration::from_secs(1)).await; }
let mut x = 10; unsafe { let p: *mut i32 = &mut x; *p = 42; }
```

Python

```python
import asyncio
async def foo():
    await asyncio.sleep(1)
```

TypeScript

```ts
async function foo() {
  await new Promise(r => setTimeout(r, 1000));
}
```

---

## 8. クラス継承・インターフェース実装の対応

|言語|クラス継承|複数継承|契約の複数実装|デフォルト実装|
|---|---|---|---|---|
|C#|単一|×|○（複数 interface）|○（default interface methods）|
|Rust|×（構造体継承なし）|×|○（複数 trait）|○（trait 内に既定実装）|
|Python|○|○|○（ABC）|○|
|TypeScript|単一|×|○（複数 interface）|×（interface は型のみ。class 継承で実装）|

---

## 9. 多重継承／多重実装時の衝突解決

Rust（明示呼出し）

```rust
trait A { fn hello(&self) { println!("A"); } }
trait B { fn hello(&self) { println!("B"); } }
struct T;
impl A for T {}
impl B for T {}
impl T { fn greet(&self) { A::hello(self); B::hello(self); } }
```

Python（MRO: 左優先）

```python
class A:  def hello(self): print("A")
class B:  def hello(self): print("B")
class C(A, B): pass
C().hello()  # A
```

C# / TypeScript

- インターフェースは型／契約のみ。衝突は実装クラス側で単一の実体を与える。
    

---

## 10. 実務の指針（まとめ）

- 派生ツリーは小さく保ち、拡張は C#/TS: interface、Rust: trait、Python: ABC/mixin を優先する。
    
- モジュール境界の可視性は C#: `internal`、Rust: `pub(crate)` を適切に使い分ける。
    
- null 取り扱いは C#: `T?`、Rust: `Option<T>`、TS: ユニオン型、Python: `None` を前提に API 設計する。
    

---

### 参照

- 文法横断: [[01-４言語-横断チートシート]]
    
- 標準操作: [[03-４言語-標準操作チートシート]]
    
- プリミティブ型の詳細: [[05-４言語-プリミティブ型完全比較]]
