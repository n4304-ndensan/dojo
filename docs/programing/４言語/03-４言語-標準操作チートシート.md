
C# / Rust / Python / TypeScript の日常使用頻度が高い標準操作を、最小コードで横断比較する。順序は C# → Rust → Python → TypeScript。

---

## 1. コレクション操作

### 1.1 配列・リスト（作成／追加／挿入／削除／長さ／ソート／部分取得）

C#

```csharp
// 作成
var a = new int[] { 1, 2, 3 };           // 固定長
var list = new List<int> { 1, 2, 3 };    // 可変長

// 追加・挿入・削除
list.Add(4);
list.Insert(1, 99);
list.Remove(2);            // 値を1つ削除
list.RemoveAt(0);          // 位置指定で削除

// 長さ・ソート
int n = list.Count;
list.Sort();               // 破壊的ソート

// 部分取得・検索
var sub = list.GetRange(1, 2);
int idx = list.IndexOf(99); // 見つからなければ -1
```

Rust

```rust
// 作成
let a: [i32; 3] = [1, 2, 3];       // 固定長
let mut v = vec![1, 2, 3];          // 可変長

// 追加・挿入・削除
v.push(4);
v.insert(1, 99);
if let Some(i) = v.iter().position(|x| *x == 2) { v.remove(i); }

// 長さ・ソート
let n = v.len();
v.sort();                           // 破壊的ソート

// 部分取得
let s: &[i32] = &v[1..3];          // スライス参照（非コピー）
let sub = v[1..3].to_vec();         // コピー
```

Python

```python
# 作成
lst = [1, 2, 3]

# 追加・挿入・削除
lst.append(4)
lst.insert(1, 99)
lst.remove(2)             # 最初の 2 を削除（なければ ValueError）
_ = lst.pop(0)            # 位置指定で取り出し

# 長さ・ソート
n = len(lst)
lst.sort()                # 破壊的。非破壊は sorted(lst)

# 部分取得（常に新しいリスト）
sub = lst[1:3]
```

TypeScript

```ts
// 作成
let arr: number[] = [1, 2, 3];

// 追加・挿入・削除
arr.push(4);
arr.splice(1, 0, 99);          // (開始, 削除数, 挿入...)
arr = arr.filter(x => x !== 2); // 値で削除（非破壊）

// 長さ・ソート
const n = arr.length;
arr.sort((a, b) => a - b);     // 数値昇順

// 部分取得・コピー
const sub = arr.slice(1, 3);
const copied = [...arr];
```

### 1.2 連想配列（辞書）

C#

```csharp
var d = new Dictionary<string, int> { ["a"] = 1 };
d["b"] = 2;
bool hasA = d.ContainsKey("a");
foreach (var kv in d) { /* kv.Key, kv.Value */ }
```

Rust

```rust
use std::collections::HashMap;
let mut m: HashMap<&str, i32> = HashMap::new();
m.insert("a", 1);
m.insert("b", 2);
let has_a = m.contains_key("a");
for (k, v) in &m { /* ... */ }
```

Python

```python
d = {"a": 1}
d["b"] = 2
has_a = ("a" in d)
for k, v in d.items():
    pass
```

TypeScript

```ts
const d: Record<string, number> = { a: 1 };
d["b"] = 2;
const hasA = ("a" in d);
for (const [k, v] of Object.entries(d)) {
  // ...
}
```

### 1.3 集合（重複排除）

C#

```csharp
var s = new HashSet<int> { 1, 2, 2 }; // {1,2}
s.Add(3); s.Remove(1);
```

Rust

```rust
use std::collections::HashSet;
let mut s: HashSet<i32> = HashSet::new();
s.insert(1); s.insert(2); s.insert(2);
s.remove(&1);
```

Python

```python
s = {1, 2, 2}
s.add(3)
s.discard(1)   # 存在しなくてもエラーなし
```

TypeScript

```ts
const s = new Set<number>([1, 2, 2]);
s.add(3);
s.delete(1);
```

### 1.4 高階関数（map / filter / reduce）

C#

```csharp
var xs = new List<int>{1,2,3};
var y = xs.Select(x => x*2).Where(x => x > 2).ToList();
var sum = xs.Aggregate(0, (a, b) => a + b);
```

Rust

```rust
let xs = vec![1,2,3];
let y: Vec<_> = xs.iter().map(|x| x*2).filter(|x| *x > 2).collect();
let sum: i32 = xs.iter().sum();
```

Python

```python
xs = [1,2,3]
y = [x*2 for x in xs if x*2 > 2]
from functools import reduce
sumv = reduce(lambda a,b: a+b, xs, 0)
```

TypeScript

```ts
const xs = [1,2,3];
const y = xs.map(x => x*2).filter(x => x > 2);
const sum = xs.reduce((a, b) => a + b, 0);
```

---

## 2. 文字列操作

C#

```csharp
var s = "Hello " + name;
int len = s.Length;
var parts = s.Split(' ');
var t = s.Replace("a", "b");
bool has = s.Contains("a");
var trimmed = s.Trim();
var sub = s.Substring(0, 5);
```

Rust

```rust
let s = format!("Hello {}", name);
let len = s.len();                  // バイト長
let parts: Vec<&str> = s.split(' ').collect();
let t = s.replace("a", "b");
let has = s.contains("a");
let trimmed = s.trim();
let sub = &s[0..5];                 // 文字境界に注意（UTF-8）
```

Python

```python
s = "Hello " + name
length = len(s)
parts = s.split()
t = s.replace("a", "b")
has_a = ("a" in s)
trimmed = s.strip()
sub = s[:5]
```

TypeScript

```ts
const s = "Hello " + name;
const len = s.length;
const parts = s.split(" ");
const t = s.replace("a", "b");
const has = s.includes("a");
const trimmed = s.trim();
const sub = s.slice(0, 5);
```

備考: 書式化・フォーマット比較（C# 補間文字列, Rust `format!`, Python f-string, TS テンプレート）は「06-文字列フォーマット-正規表現-パス操作.md」を参照。

---

## 3. JSON 操作

C#（System.Text.Json）

```csharp
using System.Text.Json;
var doc = JsonDocument.Parse(json);             // 文字列→DOM
string outJson = JsonSerializer.Serialize(obj); // オブジェクト→文字列
var id = doc.RootElement.GetProperty("id");
```

Rust（serde_json）

```rust
use serde_json::Value;
let v: Value = serde_json::from_str(&json)?;   // 文字列→Value
let s = serde_json::to_string(&v)?;            // オブジェクト→文字列
let id = &v["id"];                             // 要素取得
```

Python（標準 json）

```python
import json
obj = json.loads(json_str)
s = json.dumps(obj)
idv = obj["id"]
```

TypeScript（JSON グローバル）

```ts
const obj = JSON.parse(jsonStr);
const s = JSON.stringify(obj);
const id = obj.id;
```

---

## 4. HTTP リクエスト

C#（HttpClient）

```csharp
using var client = new HttpClient();
string s = await client.GetStringAsync(url);                 // GET
var res = await client.PostAsync(url, new StringContent(json)); // POST
client.DefaultRequestHeaders.Add("Auth", "x");
```

Rust（reqwest）

```rust
use reqwest::Client;
let client = Client::new();
let s = client.get(url).send().await?.text().await?;         // GET
let _ = client.post(url).body(json).send().await?;            // POST
```

Python（requests）

```python
import requests
r = requests.get(url)                                        # GET
r2 = requests.post(url, json={"a": 1})                        # POST
j = r.json()
```

TypeScript（fetch: ブラウザ/Node 18+）

```ts
const s = await (await fetch(url)).text();
const r = await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(data) });
const j = await (await fetch(url)).json();
```

---

## 5. 日付・時刻

C#

```csharp
var now = DateTime.Now;                 // ローカル
var s = now.ToString("yyyy-MM-dd");
var d = DateTime.Parse("2024-10-17");
var next = now.AddDays(1);
```

Rust（chrono）

```rust
use chrono::{Local, NaiveDate, Duration};
let now = Local::now();
let s = now.format("%Y-%m-%d").to_string();
let d = NaiveDate::parse_from_str("2024-10-17", "%Y-%m-%d")?;
let next = now + Duration::days(1);
```

Python

```python
from datetime import datetime, timedelta
now = datetime.now()
s = now.strftime("%Y-%m-%d")
d = datetime.strptime("2024-10-17", "%Y-%m-%d")
next_day = now + timedelta(days=1)
```

TypeScript

```ts
const now = new Date();
const s = now.toISOString().slice(0, 10); // YYYY-MM-DD
const d = new Date("2024-10-17");
const next = new Date(now.getTime() + 86400000);
```

---

## 6. 例外処理・エラーハンドリング

C#

```csharp
try {
    // ...
} catch (Exception e) {
    // ...
} finally {
    // ...
}
```

Rust（Result / ? 演算子）

```rust
fn f() -> Result<i32, String> { Ok(1) }
let x = match f() {
    Ok(v) => v,
    Err(e) => { 0 }
};

fn g() -> Result<(), Box<dyn std::error::Error>> {
    let _n: i32 = "42".parse()?; // ? で早期リターン
    Ok( )
}
```

Python

```python
try:
    pass
except Exception as e:
    pass
finally:
    pass
```

TypeScript

```ts
try {
  // ...
} catch (e) {
  // ...
} finally {
  // ...
}
```

---

## 7. 非同期・並行（最小例）

C#

```csharp
async Task Foo() { await Task.Delay(1000); }
await Task.WhenAll(Foo(), Foo());
```

Rust（tokio）

```rust
use tokio::time::{sleep, Duration};
use futures::future::join_all;
async fn foo() { sleep(Duration::from_secs(1)).await; }
join_all(vec![foo(), foo()]).await;
```

Python（asyncio）

```python
import asyncio
async def foo():
    await asyncio.sleep(1)
await asyncio.gather(foo(), foo())
```

TypeScript

```ts
const foo = async () => { await new Promise(r => setTimeout(r, 1000)); };
await Promise.all([foo(), foo()]);
```

備考: 非同期の設計指針（I/O バウンドと CPU バウンドの使い分け）は「10-並列-非同期-スレッド実践比較.md」を参照。

---

## 8. 参考

- 文字列フォーマット・正規表現・パス操作: [[06-４言語-文字列フォーマット-正規表現-パス操作]]
    
- 型と修飾子の詳細: [[02-４言語-型一覧と修飾子比較]]
    
- ファイル I/O 詳細: [[04-４言語-ファイル操作まとめ]]
    
- 標準ライブラリ早見: [[11-４言語-標準ライブラリ-代表モジュール-早見表]]
