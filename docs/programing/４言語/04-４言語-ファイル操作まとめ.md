
C# / Rust / Python / TypeScript（Node.js）でのファイル操作の最小実用例を横断比較する。順序は C# → Rust → Python → TypeScript。

---

## 0. 方針と注意

- 小さなファイルは「一括読み書き」、大きなファイルは「ストリーム」か「行単位」を使う。
    
- テキストは基本 UTF-8 を明示。改行コードは OS に依存（必要に応じて指定）。
    
- I/O エラーは発生しうる前提で例外／`Result` を処理する。
    

---

## 1. 一括読み込み／書き込み（小〜中サイズ向け）

### C#

```csharp
// 読み込み（UTF-8）
string text = File.ReadAllText("a.txt");
// 書き込み（上書き／追記）
File.WriteAllText("a.txt", "Hello");
File.AppendAllText("a.txt", "More");
```

### Rust

```rust
use std::fs;

let text = fs::read_to_string("a.txt")?;   // 読み込み
fs::write("a.txt", "Hello")?;             // 書き込み
```

### Python

```python
# 読み込み
text = open("a.txt", encoding="utf-8").read()
# 書き込み（上書き／追記）
open("a.txt", "w", encoding="utf-8").write("Hello")
open("a.txt", "a", encoding="utf-8").write("More")
```

### TypeScript（Node.js）

```ts
import fs from "fs";

const text = fs.readFileSync("a.txt", "utf8");
fs.writeFileSync("a.txt", "Hello");
fs.appendFileSync("a.txt", "More");
```

---

## 2. 行単位で読む（テキストストリーム／低メモリ）

### C#

```csharp
using var sr = new StreamReader("a.txt");
string? line;
while ((line = sr.ReadLine()) is not null)
{
    // 行ごとの処理
}
```

### Rust

```rust
use std::fs::File;
use std::io::{self, BufRead, BufReader};

let f = File::open("a.txt")?;
let reader = BufReader::new(f);
for line in reader.lines() {
    let line = line?; // String
    // 行ごとの処理
}
```

### Python

```python
with open("a.txt", encoding="utf-8") as f:
    for line in f:  # 1行ずつストリーム読み
        # 行ごとの処理
        pass
```

### TypeScript（Node.js）

```ts
import fs from "fs";
import readline from "readline";

const rl = readline.createInterface({
  input: fs.createReadStream("a.txt", { encoding: "utf8" })
});
for await (const line of rl) {
  // 行ごとの処理
}
```

---

## 3. バイナリ I/O（バッファ付き／サイズ大きめ）

### C#

```csharp
// 読み込み
using var fsr = new FileStream("a.bin", FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 81920);
byte[] buf = new byte[4096];
int read = fsr.Read(buf, 0, buf.Length);

// 書き込み
using var fsw = new FileStream("b.bin", FileMode.Create, FileAccess.Write);
sfw.Write(buf, 0, read);
```

### Rust

```rust
use std::fs::File;
use std::io::{Read, Write, BufReader, BufWriter};

let mut r = BufReader::new(File::open("a.bin")?);
let mut w = BufWriter::new(File::create("b.bin")?);
let mut buf = [0u8; 4096];
loop {
    let n = r.read(&mut buf)?;
    if n == 0 { break; }
    w.write_all(&buf[..n])?;
}
w.flush()?;
```

### Python

```python
with open("a.bin", "rb") as r, open("b.bin", "wb") as w:
    while True:
        chunk = r.read(4096)
        if not chunk:
            break
        w.write(chunk)
```

### TypeScript（Node.js）

```ts
import fs from "fs";

const rs = fs.createReadStream("a.bin");
const ws = fs.createWriteStream("b.bin");
rs.pipe(ws); // ストリームコピー
```

---

## 4. 大きなファイルのコピー／パイプ（ストリーム転送）

### C#

```csharp
using var src = File.OpenRead("big.dat");
using var dst = File.Create("big-copy.dat");
await src.CopyToAsync(dst);
```

### Rust

```rust
use std::io;
use std::fs::File;
use std::io::copy;

let mut src = File::open("big.dat")?;
let mut dst = File::create("big-copy.dat")?;
io::copy(&mut src, &mut dst)?;
```

### Python

```python
import shutil
shutil.copyfile("big.dat", "big-copy.dat")              # 一括
# またはストリーム
with open("big.dat", "rb") as r, open("big-copy.dat", "wb") as w:
    shutil.copyfileobj(r, w, length=1024 * 1024)
```

### TypeScript（Node.js）

```ts
import fs from "fs";
import { pipeline } from "stream/promises";

await pipeline(
  fs.createReadStream("big.dat"),
  fs.createWriteStream("big-copy.dat")
);
```

---

## 5. 非同期 I/O（待ちを隠蔽／大量・ネットワーク越し向け）

### C#（async/await）

```csharp
// 読み
using var sr = new StreamReader("a.txt");
string? whole = await sr.ReadToEndAsync();

// 書き
using var sw = new StreamWriter("b.txt");
await sw.WriteAsync("Hello");
```

### Rust（tokio）

```rust
use tokio::fs::File;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

let mut f = File::open("a.txt").await?;
let mut s = String::new();
f.read_to_string(&mut s).await?;

let mut w = File::create("b.txt").await?;
w.write_all(b"Hello").await?;
```

### Python（aiofiles）

```python
import aiofiles

async with aiofiles.open("a.txt", "r", encoding="utf-8") as f:
    text = await f.read()

async with aiofiles.open("b.txt", "w", encoding="utf-8") as f:
    await f.write("Hello")
```

### TypeScript（Node.js fs/promises）

```ts
import { promises as fs } from "fs";

const text = await fs.readFile("a.txt", "utf8");
await fs.writeFile("b.txt", "Hello");
```

---

## 6. 追記・ログ（ローテーションは専用ロガー推奨）

### C#

```csharp
using var sw = new StreamWriter("app.log", append: true) { AutoFlush = true };
sw.WriteLine($"{DateTime.UtcNow:o} message");
```

### Rust

```rust
use std::fs::OpenOptions;
use std::io::Write;

let mut f = OpenOptions::new().create(true).append(true).open("app.log")?;
writeln!(f, "{} message", chrono::Utc::now())?;
```

### Python

```python
from datetime import datetime
with open("app.log", "a", encoding="utf-8") as f:
    f.write(f"{datetime.utcnow().isoformat()} message\n")
```

### TypeScript（Node.js）

```ts
import fs from "fs";
fs.appendFileSync("app.log", `${new Date().toISOString()} message\n`);
```

---

## 7. 存在確認／情報／移動・コピー・削除／一時ファイル

### C#

```csharp
bool exists = File.Exists("a.txt");
var info = new FileInfo("a.txt"); // info.Length, info.CreationTimeUtc など
File.Move("a.txt", "b.txt");
File.Copy("b.txt", "c.txt", overwrite: true);
File.Delete("c.txt");

string tmp = Path.GetTempFileName();
```

### Rust

```rust
use std::{fs, path::Path};

let exists = Path::new("a.txt").exists();
let meta = fs::metadata("a.txt")?; // meta.len(), created() など
fs::rename("a.txt", "b.txt")?;
fs::copy("b.txt", "c.txt")?;
fs::remove_file("c.txt")?;

// 一時ファイルは tempfile クレートが便利
```

### Python

```python
import os, shutil, tempfile

exists = os.path.exists("a.txt")
size = os.path.getsize("a.txt")
os.rename("a.txt", "b.txt")
shutil.copy("b.txt", "c.txt")
os.remove("c.txt")

with tempfile.NamedTemporaryFile(delete=False) as tf:
    tmp_path = tf.name
```

### TypeScript（Node.js）

```ts
import fs from "fs";
import os from "os";
import path from "path";

const exists = fs.existsSync("a.txt");
const stat = fs.statSync("a.txt"); // stat.size, birthtime など
fs.renameSync("a.txt", "b.txt");
fs.copyFileSync("b.txt", "c.txt");
fs.unlinkSync("c.txt");

const tmp = path.join(os.tmpdir(), `tmp-${Date.now()}.tmp`);
fs.writeFileSync(tmp, "");
```

---

## 8. 文字コード・改行の要点

- C#／Rust：UTF-8 が基本。C# は `new StreamReader(path, Encoding.UTF8)` で明示可。
    
- Python：`open(..., encoding="utf-8", newline="\n")` で明示。
    
- Node.js：テキストは `"utf8"` を指定。バイナリは `Buffer`（エンコード指定不要）。
    
- 異体字や合成文字が入りうる入力では「バイト長と文字数が異なる」点に注意（Rust での `&s[0..n]` は文字境界前提）。
    

---

## 9. どれを使うか（設計指針）

- 早く書ける小タスク → 一括 API（`ReadAllText` / `read_to_string` / `open().read()` / `readFileSync`）。
    
- でかいファイル・メモリ制約 → 行単位／ストリーム（`BufReader`・`readline`・`StreamReader`）。
    
- バイナリ処理 → バッファ＋ループ or 言語のコピー関数（`io::copy` / `CopyToAsync` / `pipeline` / `copyfileobj`）。
    
- 高並行／I/O 待ちが多い → 非同期 I/O（C# async、Rust tokio、Python aiofiles、Node fs/promises/streams）。
    
- ログ → 追記モード＋自動フラッシュ（もしくは各言語のロガー導入）。
    

---

### 参照

- 標準操作の比較: [[03-４言語-標準操作チートシート]]
    
- 文字列フォーマット・正規表現・パス操作: [[06-４言語-文字列フォーマット-正規表現-パス操作]]
