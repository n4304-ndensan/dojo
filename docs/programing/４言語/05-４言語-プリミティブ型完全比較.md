
C# / Rust / Python / TypeScript のプリミティブ型を横断比較する。整数・浮動小数・文字／文字列・真偽・ビット演算・数値変換・リテラル・ヌル相当の扱いまでを網羅する。順序は C# → Rust → Python → TypeScript。

---

## 0. 本章の方針

- 「最小で実務的」を基準に、等価性が明確な表とコード例で示す。
    
- 整数・ビット演算は言語ごとの差異が大きいため、表現上の注意点を明記する。
    

---

## 1. 整数型（ビット幅・範囲・リテラル）

### 1.1 型とビット幅

|言語|型|ビット幅・性質|備考|
|---|---|---|---|
|C#|`byte`/`sbyte`/`short`/`ushort`/`int`/`uint`/`long`/`ulong`|8〜64（固定）|既定整数型は `int`（32bit）。数値演算はオーバーフロー時に既定でサイレント（`checked` で検出可）。|
|Rust|`i8..i128`/`u8..u128`/`isize`/`usize`|8〜128 + ポインタ幅|既定整数型は `i32`。`as` キャストの切り捨てに注意。`try_from` で安全変換可。|
|Python|`int`|任意精度|ビット幅無制限（メモリ依存）。整数除算は `//`。`/` は浮動小数を返す。|
|TypeScript|`number`|64-bit IEEE 754 倍精度|整数・小数を同型で表現。安全整数範囲は `±(2^53-1)`。|
|TypeScript|`bigint`|任意精度整数|リテラル末尾に `n`。`number` との混在演算不可。除算は 0 方向へ丸め。|

### 1.2 リテラル・基数表記・桁区切り

|項目|C#|Rust|Python|TypeScript|
|---|---|---|---|---|
|2/8/16 進表記|`0b1010`/`0`（8進非推奨）/`0xFF`|`0b1010`/`0o77`/`0xFF`|`0b1010`/`0o77`/`0xFF`|`0b1010`/`0o77`/`0xFF`|
|桁区切り|`1_000_000`|`1_000_000`|`1_000_000`|`1_000_000`|
|型サフィックス|`1L` `1UL` `1F` `1D` `1M`|`42i64` `1u128` `1f32`|なし|`9007199254740993n`（BigInt）|

### 1.3 算術の相違（整数）

|事項|C#|Rust|Python|TypeScript|
|---|---|---|---|---|
|`/` の結果|整数同士は整数（切り捨て）|同左|常に浮動小数|浮動小数（`number`）|
|整数除算|`a / b`|`a / b`|`a // b`|BigInt 同士なら `a/b` は BigInt（0 方向丸め）|
|端数演算|`%`|`%`|`%`（Python の `%` は被除数の符号に追随）|`%`|

---

## 2. 浮動小数点（型・特殊値・判定）

|言語|型|ビット幅|主な API/判定|
|---|---|---|---|
|C#|`float`/`double`/`decimal`|32/64/128（decimal は 10 進固定小数）|`double.IsNaN(x)`/`double.IsInfinity(x)`、金融計算は `decimal`|
|Rust|`f32`/`f64`|32/64|`x.is_nan()`/`x.is_infinite()`|
|Python|`float`（倍精度）|64|`math.isnan(x)`/`math.isfinite(x)`、`float('nan')`/`float('inf')`|
|TypeScript|`number`|64|`Number.isNaN(x)`/`Number.isFinite(x)`、`NaN`/`Infinity`|

注意点

- `NaN == NaN` は常に偽（全言語）。等価判定は API を使う。
    
- C# の `decimal` は丸め誤差を抑えるが、演算速度は `double` より遅い。
    

---

## 3. 文字・文字列

|言語|文字型|文字列|エンコーディングと長さ|
|---|---|---|---|
|C#|`char`（UTF-16 コード単位）|`string`（不変）|`string.Length` は UTF-16 のコード単位数。サロゲート対に注意。|
|Rust|`char`（Unicode スカラ値, 4 バイト）|`&str`（不変スライス）/`String`（所有）|`s.len()` はバイト長。`s.chars().count()` が文字数。スライスは文字境界に限る。|
|Python|文字型なし（1 文字 `str`）|`str`（不変）|`len(s)` は文字数（実装は UTF-8/16/32 だが論理文字数を返す）。|
|TypeScript|文字型なし|`string`（不変, UTF-16）|`length` は UTF-16 コード単位。サロゲートで 1 文字が 2 カウントのことがある。|

文字列リテラル

- C#: `"..."`、逐語的文字列 `@"C:\path\file"`
    
- Rust: `"..."`、生文字列 `r#"..."#`
    
- Python: `"..."`/`'...'`/三重クォート `"""..."""`
    
- TypeScript: `"..."`/テンプレート `` `...${x}...` ``
    

---

## 4. 真偽値と条件式の型

|言語|真偽型|条件式の受理型|備考|
|---|---|---|---|
|C#|`bool`|`bool` のみ|`if (x)` は `bool` に限定。|
|Rust|`bool`|`bool` のみ|暗黙変換なし。|
|Python|`bool`（`int` のサブクラス）|任意オブジェクトの真偽値|`0, "", None, [], {}` は偽。|
|TypeScript|`boolean`|任意値の truthy/falsy|`if (x)` は JS の規則に従う。|

---

## 5. ビット演算（整数）

|演算|C#|Rust|Python|TypeScript|
|---|---|---|---|---|
|AND|`a & b`|`a & b`|`a & b`|`a & b`|
|OR|`a|b`|`a|b`|
|XOR|`a ^ b`|`a ^ b`|`a ^ b`|`a ^ b`|
|NOT|`~a`|`!a`|`~a`|`~a`（BigInt も可）|
|左/右シフト|`a << n` / `a >> n`|同左（算術/論理は型次第）|同左（任意精度）|`a << n` / `a >> n`（`number` は 32bit に丸め）|

注意点

- TypeScript の `number` に対するビット演算は 32bit 符号付きに内部変換される（`>>>` はゼロ埋め右シフト、BigInt では不可）。
    
- Python と BigInt は任意精度でビット演算できる。
    
- Rust のシフト量はビット幅未満である必要がある（オーバーシフトは未定義動作ではないがパニック回避のため注意）。
    

---

## 6. 数値変換（文字列⇔数値・安全変換）

|変換|C#|Rust|Python|TypeScript|
|---|---|---|---|---|
|文字列→整数|`int.Parse("42")`|`"42".parse::<i32>()?`|`int("42")`|`Number("42")`（BigInt: `BigInt("42")`）|
|文字列→浮動小数|`double.Parse("3.14")`|`"3.14".parse::<f64>()?`|`float("3.14")`|`Number("3.14")`|
|数値→文字列|`n.ToString()`|`n.to_string()`|`str(n)`|`n.toString()`（BigInt も可）|
|安全変換|`checked((int)l)`|`i32::try_from(x)?`|そもそも任意精度|`Number.isSafeInteger(x)` を確認|

---

## 7. リテラル早見表

|種別|C#|Rust|Python|TypeScript|
|---|---|---|---|---|
|数値|`123`, `1_000`, `0xFF`, `0b1010`, `1M`|`123`, `1_000`, `0xFF`, `0b1010`, `42i64`|`123`, `1_000`, `0xFF`, `0b1010`|`123`, `1_000`, `0xFF`, `0b1010`, `9007199254740993n`|
|文字列|`"a"`, `@"C:\\x"`|`"a"`, `r#"a"#`|`"a"`, `"""a"""`|`"a"`, `` `a` ``|
|特殊値|`double.NaN`, `double.PositiveInfinity`|`f64::NAN`, `f64::INFINITY`|`float('nan')`, `float('inf')`|`NaN`, `Infinity`|

---

## 8. ヌル相当の扱い（参考）

|言語|ヌル相当|代表的な使い方|
|---|---|---|
|C#|`null`, `T?`（nullable）|`string? s = null; if (s is null) {...}`|
|Rust|なし（`Option<T>` を使用）|`let x: Option<i32> = None; if x.is_none() {...}`|
|Python|`None`|`x is None`|
|TypeScript|`null` / `undefined`|`let x: number|

---

## 9. 代表コード（差異が出やすい部分）

### 9.1 TypeScript の安全整数と BigInt

```ts
const a = 9007199254740992;              // 2^53, 非安全領域
console.log(Number.isSafeInteger(a));    // false
const b = 9007199254740993n;             // BigInt リテラル
console.log(b + 2n);                     // 9007199254740995n
// console.log(b + 2);                   // TypeError: number と混在不可
```

### 9.2 Rust の文字列スライスと文字境界

```rust
let s = "😊a".to_string();
// let x = &s[0..1]; // パニック（文字境界外）
let first = s.chars().next().unwrap();   // 正しい取り出し
```

### 9.3 Python の除算

```python
7 / 2   # 3.5（float）
7 // 2  # 3   （整数除算）
```

### 9.4 C# の decimal と double

```csharp
double d = 0.1 + 0.2;   // 0.30000000000000004 などの誤差
decimal m = 0.1m + 0.2m; // 0.3（金融向け）
```

---

## 10. 実務指針（要約）

- 型をまたぐ演算は「暗黙変換の有無」と「精度／範囲」を必ず確認する。
    
- JavaScript/TypeScript の `number` は安全整数境界を意識し、境界を越える場合は `bigint` に切り替える。
    
- 文字列の「長さ」は符号化の単位と一致しないことがある（C#/TS は UTF-16 コード単位、Rust はバイト長）。
    
- C# の数値オーバーフローは `checked` で検出、Rust は `try_from`/`Wrapping` など意図を明確にする。
    

---

### 参照

- 文法横断: [[01-４言語-横断チートシート]]
    
- 型・修飾子: [[02-４言語-型一覧と修飾子比較]]
    
- 標準操作: [[03-４言語-標準操作チートシート]]