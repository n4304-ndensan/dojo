
C# / Rust / Python / TypeScript（Node.js）を同順で比較する。文字列のフォーマット、正規表現の最小操作、パス操作（結合・正規化・抽出）を実務ベースで対比する。

---

## 1. 文字列フォーマット（補間・生文字列・複数行）

### 1.1 基本の補間・フォーマット

C#（補間 `$"...{expr}..."` / 伝統 `string.Format`）

```csharp
string name = "Alice";
int n = 3;
var s1 = $"Hello {name}, {n + 1}";
var s2 = string.Format("Hello {0}, {1}", name, n + 1);
```

Rust（`format!` マクロ / `println!` 同様）

```rust
let name = "Alice";
let n = 3;
let s = format!("Hello {}, {}", name, n + 1);
// 名前付きフォーマットは {name = ...} で代替可（1.58+）
let s2 = format!("Hello {name}, {m}", name = name, m = n + 1);
```

Python（f-string / `format`）

```python
name = "Alice"; n = 3
s1 = f"Hello {name}, {n + 1}"
s2 = "Hello {0}, {1}".format(name, n + 1)
```

TypeScript（テンプレートリテラル）

```ts
const name = "Alice"; const n = 3;
const s = `Hello ${name}, ${n + 1}`;
```

### 1.2 生（raw）文字列・パスの書きやすさ

C#（逐語的 `@`、補間と併用可：`$@` または `@$`）

```csharp
var p = @"C:\Users\Alice\file.txt";
var p2 = $@"C:\Users\{name}\file.txt";
```

Rust（生文字列 `r#"..."#`。`#` の数で入れ子可能）

```rust
let p = r"C:\Users\Alice\file.txt";
let json = r#"{"name":"Alice","note":"a\nb"}"#;
```

Python（raw 文字列 `r"..."`。末尾のバックスラッシュ単独は不可）

```python
p = r"C:\Users\Alice\file.txt"
```

TypeScript（テンプレートはそのまま複数行、`String.raw` タグでエスケープ抑止）

```ts
const p = String.raw`C:\Users\Alice\file.txt`;
```

### 1.3 複数行

C#

```csharp
var multi = @"line1
line2";
```

Rust

```rust
let multi = "line1\n
after"; // バックスラッシュ続きで行継続も可
```

Python

```python
multi = """line1
line2"""
```

TypeScript

```ts
const multi = `line1
line2`;
```

---

## 2. 正規表現（マッチ／抽出／置換）

### 2.1 使うライブラリ

|言語|ライブラリ/型|備考|
|---|---|---|
|C#|`System.Text.RegularExpressions.Regex`|オプション指定でコンパイル・大文字小文字無視等|
|Rust|`regex::Regex`（外部クレート）|RE2 由来の安全・高速実装。後読み等一部未対応|
|Python|`re`|PCRE 互換ではないが広範囲に対応|
|TypeScript|`RegExp`（JS 標準）|フラグ `gimuy` 等。`d` や後読みは環境依存（現行 Node/V8 は対応）|

### 2.2 最小操作（マッチ・グループ抽出）

C#

```csharp
using System.Text.RegularExpressions;
var re = new Regex(@"(\w+)-(\d+)");
var m = re.Match("item-42");
if (m.Success) {
    var a = m.Groups[1].Value; // "item"
    var b = int.Parse(m.Groups[2].Value); // 42
}
```

Rust

```rust
use regex::Regex;
let re = Regex::new(r"(\w+)-(\d+)").unwrap();
if let Some(caps) = re.captures("item-42") {
    let a = &caps[1];
    let b: i32 = caps[2].parse().unwrap();
}
```

Python

```python
import re
m = re.search(r"(\w+)-(\d+)", "item-42")
if m:
    a = m.group(1)
    b = int(m.group(2))
```

TypeScript

```ts
const re = /(\w+)-(\d+)/;
const m = re.exec("item-42");
if (m) {
  const a = m[1];
  const b = Number(m[2]);
}
```

### 2.3 フラグ／オプション（大文字小文字無視・複数行）

C#

```csharp
var re = new Regex("abc", RegexOptions.IgnoreCase | RegexOptions.Multiline);
```

Rust

```rust
let re = Regex::new(r"(?im)abc").unwrap(); // 内部フラグ i=ignorecase, m=multiline
```

Python

```python
re.search(r"abc", text, flags=re.I | re.M)
```

TypeScript

```ts
const re = /abc/im; // i=ignorecase, m=multiline
```

### 2.4 置換

C#

```csharp
var outText = Regex.Replace(text, @"\d+", "#");
```

Rust

```rust
use regex::Regex;
let re = Regex::new(r"\d+").unwrap();
let out_text = re.replace_all(text, "#");
```

Python

```python
import re
out_text = re.sub(r"\d+", "#", text)
```

TypeScript

```ts
const outText = text.replace(/\d+/g, "#");
```

### 2.5 名前付きグループと後読み（環境差）

C#（名前付き）

```csharp
var re = new Regex(@"(?<name>\w+)-(?<id>\d+)");
var m = re.Match("item-42");
var name = m.Groups["name"].Value; // "item"
```

Rust（名前付き）

```rust
let re = Regex::new(r"(?P<name>\w+)-(?P<id>\d+)").unwrap();
let caps = re.captures("item-42").unwrap();
let name = &caps["name"]; // "item"
```

Python（名前付き・後読み）

```python
m = re.search(r"(?P<name>\w+)-(?P<id>\d+)", "item-42")
# 後読みの例（サポートあり）
re.search(r"(?<=ID=)\d+", "ID=42")
```

TypeScript（名前付き・後読みは実行環境に依存。Node 12+ 以降は概ね可）

```ts
const m = /(?<name>\w+)-(?<id>\d+)/.exec("item-42");
const look = /(?<=ID=)\d+/.exec("ID=42");
```

### 2.6 実務の注意

- パフォーマンス: 繰り返し使う正規表現は**コンパイル済み**を再利用する。
    
    - C#: `new Regex(p, RegexOptions.Compiled)` をフィールドで使い回す。
        
    - Rust: `once_cell::sync::Lazy` や `lazy_static!` で `Regex` を静的初期化。
        
    - Python: `re.compile` を使い回す。
        
    - TypeScript: `const re = /.../g` をモジュールスコープで再利用。
        
- 文字列リテラルは**raw 文字列**を優先し、バックスラッシュの二重エスケープを避ける。
    
- JS/TS の `g` フラグと `RegExp#exec` の組合せは `lastIndex` に注意（状態を持つ）。
    

---

## 3. パス操作（結合・正規化・抽出）

前提: TypeScript は Node.js の `path`/`fs` を用いる（ブラウザではファイルシステムに非対応）。

### 3.1 結合・正規化・絶対化

C#（`System.IO.Path`）

```csharp
using System.IO;
var p = Path.Combine("/usr", "local", "bin");
var norm = Path.GetFullPath("../dir/./a.txt");
var abs = Path.GetFullPath("a.txt");
```

Rust（`std::path::{Path, PathBuf}`）

```rust
use std::path::{Path, PathBuf};
let p = Path::new("/usr").join("local").join("bin");
let abs = std::fs::canonicalize("a.txt")?; // 実体に基づく正規化（シンボリックリンク解決）
```

Python（`pathlib.Path` 推奨）

```python
from pathlib import Path
p = Path("/usr") / "local" / "bin"
abs_p = (Path("a.txt").resolve())
```

TypeScript（Node.js `path`）

```ts
import path from "path";
const p = path.join("/usr", "local", "bin");
const norm = path.normalize("../dir/./a.txt");
const abs = path.resolve("a.txt");
```

注意: `canonicalize`/`resolve` は**実ファイル**に依存する正規化（リンク解決）を行う場合がある。存在しないパスはエラーや期待外の結果になることがある。

### 3.2 要素抽出（ディレクトリ名・拡張子・ファイル名）

C#

```csharp
var dir = Path.GetDirectoryName(p);
var name = Path.GetFileName(p);
var stem = Path.GetFileNameWithoutExtension(p);
var ext = Path.GetExtension(p); // ".txt"
```

Rust

```rust
use std::path::Path;
let path = Path::new("/tmp/a.txt");
let dir = path.parent();
let name = path.file_name();
let stem = path.file_stem();
let ext = path.extension();
```

Python

```python
from pathlib import Path
path = Path("/tmp/a.txt")
dir = path.parent
name = path.name
stem = path.stem
ext = path.suffix  # ".txt"
```

TypeScript

```ts
import path from "path";
const dir = path.dirname("/tmp/a.txt");
const name = path.basename("/tmp/a.txt");
const ext = path.extname("/tmp/a.txt");
const stem = path.basename("/tmp/a.txt", ext);
```

### 3.3 区切り文字と OS 差

- C#: `Path.DirectorySeparatorChar` を用いる。文字列結合は避け `Path.Combine` を使う。
    
- Rust: `Path`/`PathBuf` は OS 依存のセパレータを吸収する。手書きの `/` `\\` を避ける。
    
- Python: `pathlib` は OS 差を吸収。`os.path` よりも `pathlib` を推奨。
    
- TypeScript: `path.posix` / `path.win32` で明示的に固定可能。クロス環境では `path.join` を使用。
    

### 3.4 ディレクトリ列挙（おまけ）

C#

```csharp
foreach (var f in Directory.EnumerateFiles("dir", "*.txt")) { }
```

Rust

```rust
for entry in std::fs::read_dir("dir")? { let p = entry?.path(); }
```

Python

```python
from pathlib import Path
for p in Path("dir").glob("*.txt"):
    pass
```

TypeScript

```ts
import fs from "fs";
for (const f of fs.readdirSync("dir")) { /* フィルタは自前 */ }
```

---

## 4. 実務指針（まとめ）

- 文字列は raw 文字列・テンプレートを使ってエスケープを最小化する。
    
- 正規表現はコンパイル済みの再利用が基本。入力スキーマが決まっていれば**パーサ**や**トークナイザ**の検討も有効。
    
- パスは `Path/PathBuf/pathlib/path` の API を使い、文字列連結を避ける。OS 差をコードで吸収する。
    
- 正規化には「文字列正規化（`normalize`）」と「実体解決（`canonicalize/resolve`）」がある。用途で使い分ける。
    

---

### 参照

- 文法横断: [[01-４言語-横断チートシート]]
    
- 標準操作: [[03-４言語-標準操作チートシート]]
    
- ファイル I/O: [[04-４言語-ファイル操作まとめ]]