
C# / Rust / Python / TypeScript（Node.js）について、ソースの分割と import、依存の追加方法、最小のテスト実行までを横断比較する。ディレクトリ構成は小規模〜中規模を想定。

---

## 0. ゴールと前提

- 目的: 「ファイルを分ける→参照する→依存を足す→テストを回す」一連の流れを各言語で再現できること。
    
- OS 非依存の構成とコマンドを優先。Node は npm を基準に記載。
    

---

## 1. モジュール／名前空間の基本

### 1.1 C#（namespace／`using`）

構成例

```
app/
  Program.cs
  Utils/
    MathEx.cs
```

`Utils/MathEx.cs`

```csharp
namespace App.Utils;
public static class MathEx
{
    public static int Twice(int x) => x * 2;
}
```

`Program.cs`

```csharp
using App.Utils;
Console.WriteLine(MathEx.Twice(21));
```

ポイント

- ファイル先頭の `namespace` が論理名空間。C# 10 以降は「ファイル スコープ namespace」記法が簡潔。
    
- プロジェクト（csproj）単位でアセンブリが生成。別プロジェクトをまたぐなら「プロジェクト参照」を追加。
    

---

### 1.2 Rust（module／`use`／`pub`）

構成例

```
app/
  src/
    main.rs
    utils/
      mod.rs
      math.rs
```

`src/utils/mod.rs`

```rust
pub mod math;
```

`src/utils/math.rs`

```rust
pub fn twice(x: i32) -> i32 { x * 2 }
```

`src/main.rs`

```rust
mod utils;          // ルートに登録
use utils::math;    // 参照

fn main() {
    println!("{}", math::twice(21));
}
```

ポイント

- `mod` でモジュールを宣言し、可視化には `pub` が必要。
    
- クレート境界（別パッケージ）を越える公開は `pub` または `pub(crate)` などスコープ指定を使う。
    

---

### 1.3 Python（パッケージ／`import`／相対 import）

構成例（`src` レイアウト）

```
app/
  pyproject.toml
  src/
    app/
      __init__.py
      main.py
      utils/
        __init__.py
        math_ex.py
```

`src/app/utils/math_ex.py`

```python
def twice(x: int) -> int:
    return x * 2
```

`src/app/main.py`

```python
from app.utils.math_ex import twice
print(twice(21))
```

ポイント

- ディレクトリがパッケージ。`__init__.py` を置く（近年は必須ではない環境もあるが明示推奨）。
    
- 相対 import は `from .utils import math_ex` のように書けるが、アプリ側は絶対 import を推奨。
    

---

### 1.4 TypeScript（ES Modules／`import`／パス別名）

構成例

```
app/
  package.json
  tsconfig.json
  src/
    main.ts
    utils/
      mathEx.ts
```

`src/utils/mathEx.ts`

```ts
export const twice = (x: number) => x * 2;
```

`src/main.ts`

```ts
import { twice } from "./utils/mathEx";
console.log(twice(21));
```

パス別名（任意）  
`tsconfig.json`

```json
{
  "compilerOptions": {
    "baseUrl": "./src",
    "paths": { "@/*": ["*"] }
  }
}
```

`src/main.ts`

```ts
import { twice } from "@/utils/mathEx";
```

---

## 2. 依存管理（追加／ロック／更新）

### 2.1 C#（.NET + NuGet）

作成と実行

```bash
dotnet new console -n app
cd app
```

依存追加

```bash
dotnet add package Newtonsoft.Json
```

復元とビルド

```bash
dotnet restore
dotnet build
```

ポイント

- 依存は `*.csproj` に `<ItemGroup><PackageReference …/></ItemGroup>` として記録。
    
- ソリューション配下の複数プロジェクトは `dotnet new sln` と `dotnet sln add` で管理。
    

---

### 2.2 Rust（Cargo）

作成と実行

```bash
cargo new app
cd app
cargo run
```

依存追加（`Cargo.toml`）

```toml
[dependencies]
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

更新

```bash
cargo update   # Cargo.lock を更新
```

ポイント

- ワークスペースで複数クレートを管理可能（後述）。
    

---

### 2.3 Python（`venv` + `pip` 基本、`pyproject.toml` 準拠）

仮想環境とインストール

```bash
python -m venv .venv
source ./.venv/bin/activate   # Windows: .venv\\Scripts\\Activate.ps1
pip install --upgrade pip
pip install requests
pip freeze > requirements.txt
```

`pyproject.toml` を使う最小例（PEP 621）

```toml
[project]
name = "app"
version = "0.1.0"
dependencies = [
  "requests>=2.0",
]
```

インストール

```bash
pip install .           # pyproject を解釈
```

ポイント

- 小規模は `requirements.txt`、配布や複数環境では `pyproject.toml` を推奨。
    

---

### 2.4 TypeScript（npm）

初期化

```bash
npm init -y
npm pkg set type=module    # ES Modules
npm i -D typescript ts-node @types/node
npx tsc --init
```

依存追加

```bash
npm i axios
```

ロックと更新

```bash
npm install      # package-lock.json を尊重
npm update       # 範囲内で更新
```

---

## 3. ビルド／実行

|言語|ビルド|実行|
|---|---|---|
|C#|`dotnet build`|`dotnet run`|
|Rust|`cargo build`|`cargo run`|
|Python|なし（スクリプト）|`python -m app.main`（`src` レイアウト前提）|
|TypeScript|`npx tsc -p tsconfig.json`|`node dist/main.js` または `tsx src/main.ts`/`ts-node src/main.ts`|

補足

- TypeScript は開発時に `tsx`（エコシステムツール）や `ts-node` が便利。配布は `tsc` で JS を生成。
    

---

## 4. テスト最小例（ユニット）

### 4.1 C#（xUnit 最小）

インストール

```bash
dotnet new xunit -n App.Tests
dotnet add App.Tests/App.Tests.csproj reference app/app.csproj
```

テストコード `App.Tests/MathExTests.cs`

```csharp
using App.Utils;
using Xunit;

public class MathExTests
{
    [Fact]
    public void Twice_Works()
    {
        Assert.Equal(84, MathEx.Twice(42));
    }
}
```

実行

```bash
dotnet test
```

---

### 4.2 Rust（組み込み `#[test]`）

`src/utils/math.rs`

```rust
pub fn twice(x: i32) -> i32 { x * 2 }

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn twice_works() { assert_eq!(twice(42), 84); }
}
```

実行

```bash
cargo test
```

---

### 4.3 Python（pytest 最小）

インストール

```bash
pip install pytest
```

テストコード `tests/test_math_ex.py`

```python
from app.utils.math_ex import twice

def test_twice():
    assert twice(42) == 84
```

実行

```bash
pytest -q
```

標準ライブラリ `unittest` の最小例

```python
import unittest
from app.utils.math_ex import twice

class T(unittest.TestCase):
    def test_twice(self):
        self.assertEqual(twice(42), 84)

if __name__ == '__main__':
    unittest.main()
```

---

### 4.4 TypeScript（Jest 最小）

インストール

```bash
npm i -D jest ts-jest @types/jest
npx ts-jest config:init
```

テストコード `src/utils/mathEx.test.ts`

```ts
import { twice } from "./mathEx";

test("twice", () => {
  expect(twice(42)).toBe(84);
});
```

実行

```bash
npx jest -c jest.config.js
```

代替として `vitest`

```bash
npm i -D vitest
```

`package.json`

```json
{
  "scripts": { "test": "vitest run" }
}
```

テスト

```ts
import { describe, it, expect } from "vitest";
import { twice } from "./mathEx";

describe("twice", () => {
  it("works", () => { expect(twice(42)).toBe(84); });
});
```

---

## 5. 複数パッケージ（ワークスペース／モノレポ）

### 5.1 C#（ソリューション + プロジェクト参照）

```bash
dotnet new sln -n App
# ライブラリ
mkdir Lib && cd Lib && dotnet new classlib -n Lib && cd ..
# アプリ
mkdir Cli && cd Cli && dotnet new console -n Cli && cd ..
# 追加
dotnet sln add Lib/Lib.csproj Cli/Cli.csproj
# 参照
dotnet add Cli/Cli.csproj reference Lib/Lib.csproj
```

### 5.2 Rust（Cargo workspace）

`Cargo.toml`

```toml
[workspace]
members = ["lib", "cli"]
```

```
app/
  lib/Cargo.toml
  cli/Cargo.toml
```

ライブラリ `lib/src/lib.rs`

```rust
pub fn twice(x: i32) -> i32 { x * 2 }
```

CLI `cli/src/main.rs`

```rust
use lib::twice;
fn main(){ println!("{}", twice(21)); }
```

### 5.3 Python（ローカルパッケージの編集インストール）

```
app/
  pkg_a/pyproject.toml
  pkg_b/pyproject.toml
```

リンク（編集インストール）

```bash
pip install -e ./pkg_a
pip install -e ./pkg_b
```

`pkg_b` から `pkg_a` を参照するには `pyproject.toml` に依存を記載

```toml
[project]
dependencies = ["pkg-a>=0.1.0"]
```

### 5.4 TypeScript（npm workspaces + TS プロジェクト参照）

`package.json`

```json
{
  "private": true,
  "workspaces": ["packages/*"]
}
```

`packages/lib/package.json`

```json
{ "name": "@app/lib", "version": "0.1.0", "type": "module" }
```

`packages/cli/package.json`

```json
{ "name": "@app/cli", "version": "0.1.0", "type": "module", "dependencies": { "@app/lib": "*" } }
```

TypeScript プロジェクト参照（任意）  
`tsconfig.base.json`

```json
{ "compilerOptions": { "composite": true } }
```

---

## 6. 補足（ビルドキャッシュ／速度）

- C#: インクリメンタルビルドが既定。`dotnet watch` でホットリロードに近い開発が可能。
    
- Rust: 依存変更がないときは差分コンパイル。`cargo check` で高速型チェック。
    
- Python: 実行時コンパイル（`.pyc`）。型検査は `mypy` を別途導入。
    
- TypeScript: `incremental: true` でビルド情報を保存。`tsc --build` とプロジェクト参照で大規模化に対応。
    

---

## 7. まとめ

- C# はプロジェクト単位のアセンブリとソリューションで規模拡大に強い。
    
- Rust は `mod/pub` による明示的可視化と Cargo workspace が堅牢。
    
- Python は `src` レイアウトと仮想環境、`pyproject.toml` を基本形に据える。
    
- TypeScript は ESM 前提で import を統一し、必要なら workspaces と TS プロジェクト参照を併用する。