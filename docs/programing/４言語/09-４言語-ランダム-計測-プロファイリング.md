
C# / Rust / Python / TypeScript（Node.js/ブラウザ）の**乱数**・**時間計測**・**軽量プロファイル**を横断比較。最小例→実務向け→注意点の順で整理する。

---

## 0. 方針

- 乱数は **用途で区別**：統計・シミュレーション用の擬似乱数（再現性重視）と、セキュリティ用途（鍵・トークン）での暗号学的乱数。
    
- 計測は **高解像度タイマ**を使い、ウォームアップ・ノイズ低減を徹底。
    
- 簡易プロファイルはまず「どこが遅いか」を**粗く特定**し、その後に本格ツールへ。
    

---

## 1. 乱数（擬似／暗号学的）

C#

```csharp
// 擬似乱数（.NET 6+）
int    i = Random.Shared.Next(0, 100);   // [0,100)
double d = Random.Shared.NextDouble();   // [0,1)

// 指定分布（例: 一様整数）
int roll = Random.Shared.Next(1, 7);     // サイコロ

// 暗号学的乱数（トークン）
using System.Security.Cryptography;
byte[] buf = RandomNumberGenerator.GetBytes(16); // 128-bit
string hex = Convert.ToHexString(buf);           // 32桁HEX

// 再現性（固定シード）
var rng = new Random(12345);
```

Rust（`rand` クレート）

```rust
use rand::{Rng, thread_rng};

let mut rng = thread_rng();
let i: i32 = rng.gen_range(0..100);   // [0,100)
let d: f64 = rng.gen();                // [0,1)

// 分布
use rand::distributions::{Distribution, Uniform};
let die = Uniform::from(1..=6);
let roll = die.sample(&mut rng);

// 暗号学的乱数
use rand::rngs::OsRng;
let mut buf = [0u8; 16];
OsRng.fill(&mut buf);

// 再現性（固定シード）
use rand::{SeedableRng};
use rand::rngs::StdRng;
let mut rng = StdRng::seed_from_u64(12345);
```

Python

```python
import random, secrets

# 擬似乱数（再現性）
random.seed(12345)
print(random.randint(0, 99))     # 0..99
print(random.random())           # [0,1)
print(random.choice(["A","B"]))

# 暗号学的乱数（トークン）
print(secrets.token_hex(16))     # 32桁HEX
```

TypeScript（Node.js / Web）

```ts
// 擬似乱数（Math.random は非再現・非暗号学的）
const i = Math.floor(Math.random() * 100);
const d = Math.random();

// 暗号学的乱数
// Node.js
import { randomBytes, randomInt } from 'node:crypto';
const token = randomBytes(16).toString('hex');
const r = await randomInt(0, 100);   // [0,100)

// ブラウザ
const buf = new Uint8Array(16);
crypto.getRandomValues(buf);

// 再現性: Math.random の固定シードは標準なし（外部ライブラリ利用）
```

**注意**

- セキュリティ用途（パスワード・トークン・鍵素材）に擬似乱数は使わない。
    
- 高次分布（正規分布など）は各言語のライブラリや自前変換（Box–Muller 等）を利用。
    

---

## 2. 時間計測（高解像度タイマ）

C#

```csharp
using System.Diagnostics;
var sw = Stopwatch.StartNew();
// 計測対象
sw.Stop();
Console.WriteLine(sw.Elapsed.TotalMilliseconds);
```

Rust

```rust
use std::time::Instant;
let t0 = Instant::now();
// 計測対象
let ms = t0.elapsed().as_secs_f64() * 1000.0;
println!("{ms:.3}");
```

Python

```python
import time

# 高解像度
t0 = time.perf_counter()
# 計測対象
ms = (time.perf_counter() - t0) * 1000
print(f"{ms:.3f}")

# マイクロベンチ（粗）
import timeit
print(timeit.timeit('sum(range(1000))', number=1000))
```

TypeScript（Node.js / Web）

```ts
// Node.js: 高解像度
import { performance } from 'node:perf_hooks';
const t0 = performance.now();
// 計測対象
const ms = performance.now() - t0;
console.log(ms);

// 代替: hrtime.bigint()
const s = process.hrtime.bigint();
// 計測対象
const ms2 = Number(process.hrtime.bigint() - s) / 1e6;
```

**ノイズ低減の基本**

- ウォームアップ（JIT/キャッシュを温める）。
    
- 入出力（I/O）は分離。CPU 計測はメモリアロケーションも最小化。
    
- 複数回測定して平均・分位点（p50/p95）を見る。
    

---

## 3. 簡易プロファイル（まずは粗く当てる）

C#

```csharp
// 粗い計測（区間ごと）
var sw = Stopwatch.StartNew();
StepA(); Console.WriteLine($"A: {sw.ElapsedMilliseconds}ms"); sw.Restart();
StepB(); Console.WriteLine($"B: {sw.ElapsedMilliseconds}ms");
```

本格的計測: **BenchmarkDotNet**（推奨）

```csharp
// <PackageReference Include="BenchmarkDotNet" Version="*" />
using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running;
public class Bench { [Benchmark] public int Sum() => Enumerable.Range(0,1000).Sum(); }
public class Program { public static void Main() => BenchmarkRunner.Run<Bench>(); }
```

Rust

```rust
// 粗い計測
let t0 = std::time::Instant::now();
step_a(); eprintln!("A: {:?}", t0.elapsed());
let t1 = std::time::Instant::now();
step_b(); eprintln!("B: {:?}", t1.elapsed());
```

本格ベンチ: **criterion**（推奨）

```rust
// Cargo.toml: criterion = "0.5"
use criterion::{criterion_group, criterion_main, Criterion};
fn sum() { let _ : i32 = (0..1000).sum(); }
fn bench(c: &mut Criterion) { c.bench_function("sum", |b| b.iter(|| sum())); }
criterion_group!(benches, bench);
criterion_main!(benches);
```

Python

```python
# 粗い区間プロファイル
import time
s = time.perf_counter(); step_a(); print("A:", time.perf_counter()-s); s=time.perf_counter(); step_b(); print("B:", time.perf_counter()-s)
```

本格プロファイル: **cProfile**（標準）

```bash
python -m cProfile -o out.prof app.py
```

結果閲覧

```bash
python -m pstats out.prof
# または snakeviz: pip install snakeviz; snakeviz out.prof
```

関数単位の時間: `timeit`, 行単位は `line_profiler`（外部）。

TypeScript / Node.js

```ts
// 区間計測（タグ付き）
console.time('A'); stepA(); console.timeEnd('A');
console.time('B'); stepB(); console.timeEnd('B');
```

高解像度: `performance.now()` / `hrtime.bigint()`（前節）  
本格プロファイル: Node.js inspector/CPU プロファイル

```bash
node --inspect app.js   # DevTools で CPU profile 取得
# または --prof / --prof-process で V8 のサマリを出力
```

---

## 4. ミニユーティリティ（簡易タイマ）

C#（`using` で自動計測）

```csharp
sealed class ScopeTimer : IDisposable {
    private readonly string _name; private readonly Stopwatch _sw = Stopwatch.StartNew();
    public ScopeTimer(string name) => _name = name;
    public void Dispose() { _sw.Stop(); Console.WriteLine($"{_name}: {_sw.ElapsedMilliseconds}ms"); }
}
using (new ScopeTimer("StepA")) { StepA(); }
```

Rust（ドロップでログ）

```rust
struct ScopeTimer { name: &'static str, t0: std::time::Instant }
impl ScopeTimer { fn new(name: &'static str) -> Self { Self { name, t0: std::time::Instant::now() } } }
impl Drop for ScopeTimer { fn drop(&mut self) { eprintln!("{}: {:?}", self.name, self.t0.elapsed()); } }
{ let _t = ScopeTimer::new("step"); step(); }
```

Python（コンテキストマネージャ）

```python
from contextlib import contextmanager
import time
@contextmanager
def timer(name: str):
    s = time.perf_counter();
    try: yield
    finally: print(name, (time.perf_counter()-s)*1000, 'ms')
with timer('step'):
    step()
```

TypeScript（高精度 now 包装）

```ts
import { performance } from 'node:perf_hooks';
function time<T>(name: string, f: () => T): T {
  const s = performance.now();
  try { return f(); }
  finally { console.log(name, (performance.now()-s).toFixed(3), 'ms'); }
}
time('step', () => step());
```

---

## 5. よくある落とし穴

- **暗号用途で擬似乱数を使用**：必ず CSPRNG（C#/RandomNumberGenerator, Rust/OsRng, Python/secrets, Node/crypto）。
    
- **ベンチで I/O 混在**：ディスク・ネットワークはばらつき大。CPU 計測と分離する。
    
- **最適化により死コード**：計測対象の結果を**観察可能**に（返却・集計）して、消去を防ぐ。
    
- **JIT/ウォームアップ無視**：.NET/Node は初回が遅い。反復前にウォームアップ。
    
- **単回計測の鵜呑み**：繰り返し＋統計（平均・p95）。Criterion/BenchmarkDotNet/timeit を活用。
    

---

### 参照

- 横断チートシート: [[01-４言語-横断チートシート]]
    
- 標準操作: [[03-４言語-標準操作チートシート]]
    
- CLI/設定: [[08-４言語-CLI引数-環境変数-設定管理]]