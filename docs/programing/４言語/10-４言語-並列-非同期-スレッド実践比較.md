
C# / Rust / Python / TypeScript（Node.js）を対象に、I/O 待ちと CPU 計算で手段を選ぶ実務的な指針をまとめる。最小コードと設計パターンを併記。

---

## 0. まず押さえる用語

- **Concurrency**: 論理的な同時実行（待ち時間の隠蔽）。
    
- **Parallelism**: 物理的な同時実行（コアを増やしてスループットを上げる）。
    
- **I/O-bound**: ネットワーク・ディスク待ちが支配的。
    
- **CPU-bound**: 計算や変換が支配的。
    

---

## 1. 決定表（最短ルート）

| ワークロード           | C#                                    | Rust                               | Python                                    | Node(TypeScript)                          |
| ---------------- | ------------------------------------- | ---------------------------------- | ----------------------------------------- | ----------------------------------------- |
| I/O 多重化          | `async/await` + `Task`                | `async` + `tokio`                  | `asyncio`                                 | `Promise/async`（イベントループ）                  |
| ブロッキング I/O を封じ込め | `Task.Run` / `Channel`                | `tokio::task::spawn_blocking`      | `run_in_executor(ThreadPool)`             | `worker_threads` / 別プロセス                  |
| CPU 並列           | `Parallel.For` / `PLINQ` / `Task.Run` | `rayon`                            | `multiprocessing` / `ProcessPoolExecutor` | `worker_threads` / `cluster`              |
| キャンセル／期限         | `CancellationToken` / `Task.WhenAny`  | `tokio::time::timeout` / `select!` | `asyncio.wait_for` / `CancelledError`     | `AbortController` / `Promise.race`        |
| 共有状態             | `lock` / `Concurrent*` / `Channel<T>` | `Mutex/RwLock` / `mpsc`            | `threading.Lock` / `queue.Queue`          | メインは非共有、必要なら `Atomics` / `MessageChannel` |

原則: **I/O は async、CPU はスレッド/プロセス**。両者を混ぜるときは「封じ込め」APIを使う。

---

## 2. I/O 多重化の最小例（HTTP を並列）

C# (.NET 6+)

```csharp
using var http = new HttpClient();
var urls = new[]{"https://example.com","https://example.org"};
var tasks = urls.Select(u => http.GetStringAsync(u));
var bodies = await Task.WhenAll(tasks);
```

Rust（tokio + reqwest）

```rust
use futures::future::join_all;
let urls = vec!["https://example.com", "https://example.org"];
let tasks = urls.into_iter().map(|u| async move { reqwest::get(u).await?.text().await });
let bodies: Vec<String> = join_all(tasks).await.into_iter().collect::<Result<_,_>>()?;
```

Python（aiohttp）

```python
import aiohttp, asyncio
urls = ["https://example.com","https://example.org"]
async def main():
    async with aiohttp.ClientSession() as s:
        async def fetch(u):
            async with s.get(u) as r: return await r.text()
        bodies = await asyncio.gather(*(fetch(u) for u in urls))
    return bodies
bodies = asyncio.run(main())
```

Node（fetch）

```ts
const urls = ["https://example.com","https://example.org"];
const bodies = await Promise.all(urls.map(u => fetch(u).then(r => r.text())));
```

---

## 3. CPU 並列（配列の重い計算を並列マップ）

C#（Parallel.For / PLINQ）

```csharp
var data = Enumerable.Range(0, 1_000_000).ToArray();
Parallel.For(0, data.Length, i => data[i] = Heavy(data[i]));
// あるいは: var result = data.AsParallel().Select(Heavy).ToArray();
```

Rust（rayon）

```rust
use rayon::prelude::*;
let mut v: Vec<i64> = (0..1_000_000).collect();
v.par_iter_mut().for_each(|x| *x = heavy(*x));
```

Python（multiprocessing）

```python
from concurrent.futures import ProcessPoolExecutor
with ProcessPoolExecutor() as ex:
    result = list(ex.map(heavy, range(1_000_000)))
```

Node（worker_threads）

```ts
import { Worker } from 'node:worker_threads';
function runWorker(data: number[]): Promise<number[]> {
  return new Promise((res, rej) => {
    const w = new Worker(new URL('./worker.js', import.meta.url), { workerData: data });
    w.on('message', res); w.on('error', rej);
  });
}
const result = await runWorker([...Array(1_000_000).keys()]);
```

---

## 4. スレッドと同期（必要最低限）

C#

```csharp
var t = new Thread(() => Work()); t.Start(); t.Join();
var q = new System.Threading.Channels.Channel<int>(); // Channel.CreateUnbounded<int>() 等
```

Rust

```rust
use std::thread;
let h = thread::spawn(|| work()); h.join().unwrap();
use std::sync::{Mutex, mpsc};
let m = Mutex::new(0);
let (tx, rx) = mpsc::channel();
```

Python

```python
import threading, queue
th = threading.Thread(target=work); th.start(); th.join()
q = queue.Queue(); q.put(1); q.get()
```

Node

```ts
// 共有よりメッセージ。Atomics/SharedArrayBuffer もあるが用途限定。
const { port1, port2 } = new MessageChannel();
port1.on('message', x => {/*...*/}); port2.postMessage(1);
```

---

## 5. キャンセルとタイムアウト

C#

```csharp
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));
await Task.WhenAny(Task.Delay(Timeout.Infinite, cts.Token), WorkAsync(cts.Token));
```

Rust（tokio）

```rust
let res = tokio::time::timeout(Duration::from_secs(5), work()).await; // Err=timeout
```

Python

```python
async def main():
    try:
        await asyncio.wait_for(work(), timeout=5)
    except asyncio.TimeoutError:
        ...
```

Node

```ts
const ac = new AbortController();
setTimeout(() => ac.abort(), 5000);
await fetch(url, { signal: ac.signal });
```

---

## 6. ブロッキング API の封じ込め

| 言語     | 封じ込め API                              | 典型用途                      |
| ------ | ------------------------------------- | ------------------------- |
| C#     | `Task.Run`, `Parallel.For`, `Channel` | 同期 DB/SDK 呼び出しを隔離         |
| Rust   | `tokio::task::spawn_blocking`         | CPU/同期 I/O を非同期タスクと分離     |
| Python | `loop.run_in_executor(ThreadPool)`    | ブロッキングライブラリを asyncio 内で使用 |
| Node   | `worker_threads`, `child_process`     | CPU 変換・ネイティブアドオン呼び出し      |

---

## 7. よくある落とし穴

- **async 内でブロッキング**（全言語）: イベントループや I/O ワーカースレッドを塞ぐ。封じ込め API を使用。
    
- **C# の同期待ちデッドロック**: `Task.Result/Wait()` を UI/ASP.NET 同期コンテキストで呼ばない。`await` を徹底。
    
- **Python の GIL**: `threading` は CPU には効かない。`multiprocessing`/C拡張/NumPy を使う。
    
- **Rust の Send/Sync**: `!Send`/`!Sync` 型を誤ってスレッドに渡すとコンパイルエラー。設計で回避。
    
- **Node のイベントループ阻害**: `JSON.parse` や巨大圧縮展開など CPU が重い処理は worker へ。
    
- **共有状態の過多**: まずはメッセージパッシング（Channel/Queue）で疎結合にする。
    

---

## 8. パターン集（実務で多い）

### 8.1 バウンデッド並列（同時数制限）

C#（SemaphoreSlim）

```csharp
var sem = new SemaphoreSlim(10);
var tasks = urls.Select(async u => { await sem.WaitAsync(); try { return await http.GetStringAsync(u); } finally { sem.Release(); } });
var bodies = await Task.WhenAll(tasks);
```

Rust（Semaphore）

```rust
use tokio::sync::Semaphore;
let sem = std::sync::Arc::new(Semaphore::new(10));
let tasks = urls.into_iter().map(|u| { let sem = sem.clone(); async move { let _p = sem.acquire().await.unwrap(); reqwest::get(u).await?.text().await } });
let bodies: Vec<_> = futures::future::try_join_all(tasks).await?;
```

Python（asyncio.Semaphore）

```python
sem = asyncio.Semaphore(10)
async def fetch(u):
    async with sem:
        async with s.get(u) as r: return await r.text()
```

Node（p-limit 相当自作）

```ts
async function withLimit<T>(n: number, tasks: (()=>Promise<T>)[]) {
  const q: Promise<void>[] = []; let active = 0, i = 0, out: T[] = [];
  return new Promise<T[]>((res, rej) => {
    const run = () => {
      if (i === tasks.length && active === 0) return res(out);
      while (active < n && i < tasks.length) {
        const k = i++; active++;
        tasks[k]().then(v => out[k]=v).finally(()=>{ active--; run(); }).catch(rej);
      }
    }; run();
  });
}
```

### 8.2 パイプライン（fan-out/fan-in）

- C#: `System.Threading.Channels` で段階ごとに Channel を繋ぐ。
    
- Rust: `tokio::sync::mpsc` をステージごとに接続。
    
- Python: `asyncio.Queue` / `queue.Queue` を段階接続。
    
- Node: ストリーム/MessageChannel/worker で段階化。
    

---

## 9. 観測（最小）

- C#: `ILogger` / `Activity`（OpenTelemetry）でタスクに相関 ID を持たせる。
    
- Rust: `tracing` クレートで span と event を付与。
    
- Python: `logging` + `contextvars` で相関 ID。
    
- Node: `pino`/`winston` + `AsyncLocalStorage` で相関管理。
    

---

## 10. まとめ

1. I/O は async で数を捌き、2) CPU はスレッド/プロセスで並列化、3) 混在時は封じ込め、4) キャンセルと期限を必ず持つ。これが基本線。