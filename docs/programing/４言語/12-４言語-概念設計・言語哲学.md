C# / Rust / Python / TypeScript（Node.js）を、**設計の軸**と**言語哲学**の観点から横断比較する。API 設計・エラーモデル・並行性・性能費用モデル・進化方針まで、実務判断に直結する「考え方」をまとめる。

> 参照: `01-４言語-横断チートシート.md`, `02-４言語-型一覧と修飾子比較.md`, `03-４言語-標準操作チートシート.md`, `10-４言語-並列-非同期-スレッド実践比較.md`, `11-４言語-標準ライブラリ-代表モジュール-早見表.md`

---

## 0. 地図：何が「概念」か（設計の主要軸）

- **型と安全性**: 静的/動的、null 安全、型推論、ジェネリクスの表現力。
    
- **リソース管理**: GC / 所有権 / RAII / 参照カウント。
    
- **エラーモデル**: 例外 vs 戻り値（`Result`/`Option`）。
    
- **並行モデル**: イベントループ、スレッド、プロセス、メッセージパッシング、キャンセル。
    
- **抽象化境界**: モジュール・名前空間・可視性・ABI/FFI・パッケージング。
    
- **費用モデル**: アロケーション、ボクシング、動的ディスパッチ、JIT/AOT、I/O 待ち。
    
- **進化戦略**: バージョニング、互換性、言語の長期方針。
    

---

## 1. 言語哲学（1枚で掴む）

|言語|中心思想|開発体験|得意領域|苦手/注意|
|---|---|---|---|---|
|**C#**|実務均衡（安全/生産性/実用性能のバランス）|IDE 支援・ツール群が強力|企業アプリ、API、クラウド、GUI、ゲーム|ランタイム/GC 前提。低レイテンシ厳格要件では調整が必要|
|**Rust**|コンパイル時安全性とゼロコスト抽象|エラー早期発見・実行時オーバーヘッド最小|システム、パフォーマンス、並行処理|学習曲線、コンパイル時間、FFI/unsafe の責任範囲|
|**Python**|可読性・柔軟性・エコシステム|最短で結果、データ/AI 圧倒的|データ/AI、スクリプト、Glue|GIL による CPU 並列制約、型安全は運用で補う|
|**TypeScript**|JS の安全化（構造的型）|Web 前提・DX 良|Web/Node フルスタック|実行は JS。型はビルド時のみ。性能は JS に準ずる|

---

## 2. 型システムの立ち位置（静的/動的・構造/名義）

|事項|C#|Rust|Python|TypeScript|
|---|---|---|---|---|
|型付け|静的・名義|静的・名義|動的（型ヒント任意）|静的（構造的）|
|代数的データ型|`record`/`enum` 近似（`OneOf` 等で擬似）|`enum`（タグ付き和）|`typing.Literal`/`Union`|判別可能 Union（第一級）|
|ジェネリクス|具象/制約（`where`）|モノモーフィック（インスタンシエーション）|duck-typing（`Protocol`）|構造的型 + 条件型/ジェネリクス|
|Null 安全|参照型注釈（`?`）|`Option<T>`|`Optional[T]`|`strictNullChecks`|
|動的ディスパッチ|`virtual`/`interface`|`dyn Trait`|既定|形状一致（構造）で静的解決|

**要点**: Rust は「型で表せるものは表す」。TS は「形で一致すれば良い」。C# は名義型と OOP/FP の折衷。Python は型の自由度と実行時検証が前提。

---

## 3. メモリとリソース管理（GC/所有権/RAII）

- **C#**: GC + `IDisposable`（`using`）でネイティブ/ハンドル解放。`struct` で値型、`Span<T>`/`Memory<T>` で一部ゼロアロケ。
    
- **Rust**: 所有権/借用 + RAII。`Drop` による確定解放。`Arc/Mutex` 等で共有。`unsafe` 境界の明示。
    
- **Python**: 参照カウント + GC。`with` で外部資源解放。大きい数値/配列はネイティブ（NumPy）に委譲しメモリ効率確保。
    
- **TS/JS**: GC。`Buffer`/`ArrayBuffer` でバイナリ。FFI（C++ アドオン/N-API）を使う時は寿命管理を明確に。
    

選択指針: **確定解放が必要なら** Rust/C# の RAII/`using`。**長寿命・大量確保**はアロケ最小化（プール/スライス）を設計に織り込む。

---

## 4. エラーモデル（例外か、結果か）

- **C#**: 例外は異常系。ホットパスでは戻り値（`TryParse`）や `Result` 相当の型利用。`async` は `Task` が例外を伝播。
    
- **Rust**: `Result<T,E>` が基本。`?` で伝搬。例外は無し（`panic!` はバグ）。型で失敗を表現し、合流点で処理。
    
- **Python**: 例外中心。事前条件は `if` 検査で早期 `raise`。外縁で `try/except` を一括処理。
    
- **TS**: 例外と `Either`/`Result` ライクな合成（ライブラリ）。API は `Promise<T>` で reject を明確化。
    

原則: **ホットパスは分岐・型で処理**、**外縁で例外**。再試行ポリシーは `10-...` 参照。

---

## 5. 並行モデル（哲学と現実）

- **C#**: 非同期 I/O は `Task`、CPU は `Parallel/Task.Run`。キャンセル第一。構造化合流。
    
- **Rust**: 非同期は `tokio`、CPU は `rayon`。`Send/Sync` で安全制約。`select!`/`timeout` を常備。
    
- **Python**: I/O は `asyncio`、CPU は `ProcessPool`。GIL 回避（C拡張/NumPy）を検討。
    
- **TS/Node**: I/O は `Promise`、CPU は `worker_threads`。イベントループ阻害を避ける。
    

判断早見表は `10-...` を参照。混在は「封じ込め API」で境界管理。

---

## 6. 抽象化境界とモジュール（可視性/ABI/配布）

- **C#**: アセンブリ/namespace、`public/internal`。NuGet 配布、強名・バイナリ互換に注意。
    
- **Rust**: クレート/モジュール、`pub` と機能ゲート。**ソース互換**を重視し、`semver` と `edition` で進化。
    
- **Python**: パッケージ/モジュール。公開/非公開は慣習（`_name`）。Wheel 配布。ABI は C 拡張に注意。
    
- **TS**: ESM/CJS 混在に注意。型公開は `.d.ts`。npm 配布、ツリーシェイク考慮の API 形状。
    

---

## 7. FFI/相互運用（責務の切り分け）

- **C#**: P/Invoke, `DllImport`, COM, C++/CLI。セーフハンドルで寿命を包む。
    
- **Rust**: `extern "C"` + `unsafe`。境界で型と所有権を明確化。`cxx`/`pyo3`/`napi-rs` 等で足場を使う。
    
- **Python**: `ctypes`/`cffi`/C 拡張（`setuptools`）。型とスレッド安全は拡張側で担保。
    
- **Node**: N-API/`node-addon-api`。ABI 安定の範囲で実装。ワーカースレッドとの連携を前提に。
    

---

## 8. 性能費用モデル（何がコストか）

- **アロケーション**: ボクシング/ヒープ確保は高コスト。Rust は所有権で抑制、C# は `struct`/`Span<T>`、Python/TS はバッファ再利用。
    
- **ディスパッチ**: 仮想呼び出し/`dyn`/反射は分岐・予測ミス要因。内側ループは静的解決に寄せる。
    
- **JIT/AOT**: C#/Node は JIT。ウォームアップ考慮。Rust は AOT。Python はインタプリタ（PyPy など別実装も）。
    
- **I/O 待ち**: 可視化（トレース）し、同時数/バックプレッシャを制御。
    

---

## 9. API 設計原則（言語別の「らしさ」）

- **C#**: `TryXxx`/`XxxAsync` 命名、`IEnumerable<T>`/`IAsyncEnumerable<T>` を返す。`IDisposable` を明示。
    
- **Rust**: 最小 `trait` の組合せ、`&[T]`/`Iterator` を受け取り、`Result` で失敗を表現。`newtype` で不正値を型で排除。
    
- **Python**: `dataclasses` + 型ヒント、`typing.Protocol` でインターフェース。例外は `ValueError`/`TypeError` を使い分け。
    
- **TS**: 判別可能 Union、`readonly`/不変オブジェクト、戻り値は `Promise<Result<T,E>>` 等で握りを明確に。
    

---

## 10. 進化戦略と長期保守

- **C#/.NET**: LTS を選択。`Obsolete` 属性で段階移行。ソースジェネレータ/Record で近代化。
    
- **Rust**: edition で破壊的変更を吸収。MSRV を明示。機能フラグでバイナリ肥大化を抑制。
    
- **Python**: バージョン移行（3.8→3.12）は `tox`/`pytest` で CI マトリクス。`from __future__` で前方適合。
    
- **TS**: ESM 移行、`dom`/`node` タイピング分離。`strict` を既定、API は `readonly` 前提。
    

---

## 11. レシピ集（設計パターン）

- **入力検証**: Rust→`newtype` + `TryFrom`; C#→`Guard`/`FluentValidation`; Python→`pydantic`; TS→`zod`。
    
- **設定**: C#→`ConfigurationBuilder`; Rust→`config`+`serde`; Python→`argparse`+`.env`+`json`; TS→`yargs`+`dotenv`。
    
- **プラガブル設計**: Rust→`dyn Trait`/feature flags; C#→DI コンテナ; Python→エントリポイント; TS→ツリーシェイク前提の分割。
    
- **リトライ**: ポリシーオブジェクト化（指数バックオフ+ジッタ）。`10-...` 参照。
    

---

## 12. 決定早見表（実務）

|目的|推奨言語/形|追加メモ|
|---|---|---|
|低レイテンシ・高効率|Rust|所有権/ゼロコスト抽象、`rayon`/`tokio`|
|企業 API/長期保守|C#|一貫したツール鎖、`ILogger`/ASP.NET|
|データ/ML/Glue|Python|生産性とエコシステム。CPU は C/NumPy で補完|
|Web/フルスタック|TypeScript|構造的型 + npm。API 設計は判別可能 Union|

---

## 13. まとめ

- **安全と速度**をコンパイル時に取るなら Rust、**均衡と開発体験**なら C#、**探索と連携**は Python、**Web と統合**は TypeScript。
    
- 言語は「できる/できない」ではなく「**どのコストをどこで払うか**」の選択。型・エラー・並行・配布の各軸で、プロダクトの要件に整合させる。